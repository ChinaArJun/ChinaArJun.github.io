(window.webpackJsonp=window.webpackJsonp||[]).push([[500],{1096:function(e,t,a){"use strict";a.r(t);var r=a(44),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"给-api-命令增加版本功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给-api-命令增加版本功能"}},[e._v("#")]),e._v(" 给 API 命令增加版本功能")]),e._v(" "),a("h2",{attrs:{id:"本节核心内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本节核心内容"}},[e._v("#")]),e._v(" 本节核心内容")]),e._v(" "),a("ul",[a("li",[e._v("如何给 apiserver 增加版本功能")])]),e._v(" "),a("blockquote",[a("p",[e._v("本小节源码下载路径："),a("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo12",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo12"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("可先下载源码到本地，结合源码理解后续内容，边学边练。")]),e._v(" "),a("p",[e._v("本小节的代码是基于 "),a("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo11",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo11"),a("OutboundLink")],1),e._v(" 来开发的。")])]),e._v(" "),a("h2",{attrs:{id:"为什么需要版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要版本"}},[e._v("#")]),e._v(" 为什么需要版本")]),e._v(" "),a("p",[e._v("在实际开发中，当开发完一个 apiserver 特性后，会编译 apiserver 二进制文件并发布到生产环境，很多时候为了定位问题和出于安全目的（不能发错版本），我们需要知道当前 apiserver 的版本，以及一些编译时候的信息，如编译时 Go 的版本、Git 目录是否 clean，以及基于哪个 git commmit 来编译的。在一个编译好的可执行程序中，我们通常可以用类似 "),a("code",[e._v("./app_name -v")]),e._v(" 的方式来获取版本信息。")]),e._v(" "),a("p",[e._v("我们可以将这些信息写在配置文件中，程序运行时从配置文件中取得这些信息进行显示。但是在部署程序时，除了二进制文件还需要额外的配置文件，不是很方便。或者将这些信息写入代码中，这样不需要额外的配置，但要在每次编译时修改代码文件，也比较麻烦。Go 官方提供了一种更好的方式：通过 "),a("code",[e._v("-ldflags -X importpath.name=value")]),e._v("（详见 "),a("a",{attrs:{href:"https://golang.org/cmd/link/",target:"_blank",rel:"noopener noreferrer"}},[e._v("-ldflags -X importpath.name=value"),a("OutboundLink")],1),e._v("）来给程序自动添加版本信息。")]),e._v(" "),a("blockquote",[a("p",[e._v("在实际开发中，绝大部分都是用 Git 来做源码版本管理的，所以 apiserver 的版本功能也基于 Git。")])]),e._v(" "),a("h2",{attrs:{id:"给-apiserver-添加版本功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给-apiserver-添加版本功能"}},[e._v("#")]),e._v(" 给 "),a("code",[e._v("apiserver")]),e._v(" 添加版本功能")]),e._v(" "),a("p",[e._v("假设我们程序发布的流程是这样：")]),e._v(" "),a("ol",[a("li",[e._v("编码完成，提交测试工程师测试")]),e._v(" "),a("li",[e._v("测试工程师测试代码，提交 bug，更改 bug 并重新测试后验证通过")]),e._v(" "),a("li",[e._v("开发人员把验证通过的代码合并到 master 分支，并打上版本号："),a("code",[e._v("git tag -a v1.0.0")])]),e._v(" "),a("li",[e._v("开发人员将 "),a("code",[e._v("v1.0.0")]),e._v(" 版本发布到生产环境")])]),e._v(" "),a("p",[e._v("最终发布后，我们希望通过 "),a("code",[e._v("./apiserver -v")]),e._v(" 参数提供如下版本信息：")]),e._v(" "),a("ul",[a("li",[e._v("版本号")]),e._v(" "),a("li",[e._v("git commit")]),e._v(" "),a("li",[e._v("git tree 在编译时的状态")]),e._v(" "),a("li",[e._v("构建时间")]),e._v(" "),a("li",[e._v("go 版本")]),e._v(" "),a("li",[e._v("go 编译器")]),e._v(" "),a("li",[e._v("运行平台")])]),e._v(" "),a("p",[e._v("为了实现这些功能，我们首先要在 "),a("code",[e._v("main")]),e._v(" 函数中添加用于接收 "),a("code",[e._v("-v")]),e._v(" 参数的入口（详见 "),a("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo12/main.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo12/main.go"),a("OutboundLink")],1),e._v("）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('package main\n\nimport (\n\t"encoding/json"\n\t"fmt"\n\t"os"\n\t...\n\tv "apiserver/pkg/version"\n\t...\n)\n\nvar (\n\tversion = pflag.BoolP("version", "v", false, "show version info.")\n)\n\nfunc main() {\n\tpflag.Parse()\n\tif *version {\n\t\tv := v.Get()\n\t\tmarshalled, err := json.MarshalIndent(&v, "", "  ")\n\t\tif err != nil {\n\t\t\tfmt.Printf("%v\\n", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tfmt.Println(string(marshalled))\n\t\treturn\n\t}\n\t...\n}\n')])])]),a("p",[e._v("通过 "),a("code",[e._v("pflag")]),e._v(" 来解析命令行上传入的 "),a("code",[e._v("-v")]),e._v(" 参数。")]),e._v(" "),a("p",[e._v("通过 "),a("code",[e._v("pkg/version")]),e._v(" 的 "),a("code",[e._v("Get()")]),e._v(" 函数来获取 apiserver 的版本信息。")]),e._v(" "),a("p",[e._v("通过 "),a("code",[e._v("json.MarshalIndent")]),e._v(" 来格式化打印版本信息。")]),e._v(" "),a("p",[a("code",[e._v("pkg/version")]),e._v(" 的 "),a("code",[e._v("Get()")]),e._v(" 函数实现为（详见 "),a("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo12/pkg/version",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo12/pkg/version"),a("OutboundLink")],1),e._v("）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('func Get() Info {\n\treturn Info{\n\t\tGitTag:       gitTag,\n\t\tGitCommit:    gitCommit,\n\t\tGitTreeState: gitTreeState,\n\t\tBuildDate:    buildDate,\n\t\tGoVersion:    runtime.Version(),\n\t\tCompiler:     runtime.Compiler,\n\t\tPlatform:     fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),\n\t}\n}\n')])])]),a("p",[e._v("其中 "),a("code",[e._v("gitTag")]),e._v("、"),a("code",[e._v("gitCommit")]),e._v("、"),a("code",[e._v("gitTreeState")]),e._v(" 等变量的值是通过 "),a("code",[e._v("-ldflags -X importpath.name=value")]),e._v(" 在编译时传到程序中的。为此我们需要在编译时传入这些信息，在 Makefile 中添加如下信息（详见 "),a("a",{attrs:{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo12/Makefile",target:"_blank",rel:"noopener noreferrer"}},[e._v("demo12/Makefile"),a("OutboundLink")],1),e._v("）：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('SHELL := /bin/bash \nBASEDIR = $(shell pwd)\n \n# build with verison infos\nversionDir = "apiserver/pkg/version"\ngitTag = $(shell if [ "`git describe --tags --abbrev=0 2>/dev/null`" != "" ];then git describe --tags --abbrev=0; else git log --pretty=format:\'%h\' -n 1; fi)\nbuildDate = $(shell TZ=Asia/Shanghai date +%FT%T%z)\ngitCommit = $(shell git log --pretty=format:\'%H\' -n 1)\ngitTreeState = $(shell if git status|grep -q \'clean\';then echo clean; else echo dirty; fi)\n \nldflags="-w -X ${versionDir}.gitTag=${gitTag} -X ${versionDir}.buildDate=${buildDate} -X ${versionDir}.gitCommit=${gitCommit} -X ${versionDir}.gitTreeState=${gitTreeState}"\n')])])]),a("p",[e._v("并在 "),a("code",[e._v("go build")]),e._v(" 中添加这些 flag：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("go build -v -ldflags ${ldflags} .\n")])])]),a("blockquote",[a("p",[a("code",[e._v("-w")]),e._v(" 为去掉调试信息（无法使用 gdb 调试），这样可以使编译后的二进制文件更小。")])]),e._v(" "),a("h2",{attrs:{id:"编译并测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译并测试"}},[e._v("#")]),e._v(" 编译并测试")]),e._v(" "),a("ol",[a("li",[e._v("下载 apiserver_demos 源码包（如前面已经下载过，请忽略此步骤）")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ git clone https://github.com/lexkong/apiserver_demos\n")])])]),a("ol",[a("li",[e._v("将 "),a("code",[e._v("apiserver_demos/demo12")]),e._v(" 复制为 "),a("code",[e._v("$GOPATH/src/apiserver")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ cp -a apiserver_demos/demo12/ $GOPATH/src/apiserver\n")])])]),a("ol",[a("li",[e._v("在 apiserver 目录下编译源码")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ cd $GOPATH/src/apiserver\n$ make\n")])])]),a("p",[a("strong",[e._v("查看 apiserver 版本")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('$ ./apiserver -v\n\n{\n  "gitTag": "7322949",\n  "gitCommit": "732294928b3c4dff5b898fde0bb5313752e1173e",\n  "gitTreeState": "dirty",\n  "buildDate": "2018-06-05T07:43:26+0800",\n  "goVersion": "go1.10.2",\n  "compiler": "gc",\n  "platform": "linux/amd64"\n}\n')])])]),a("p",[e._v("可以看到 "),a("code",[e._v("./apiserver -v")]),e._v(" 输出了我们需要的版本信息。")]),e._v(" "),a("blockquote",[a("p",[e._v("在上一小节中我们已经给 "),a("code",[e._v("apiserver")]),e._v(" 添加过 Makefile 文件。")])]),e._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("p",[e._v("本小节主要介绍如何用 Makefile 以及 Go 本身所支持的编译特性，实现编译时自动生成版本号的功能。后续小节编译 API 源码均会通过 "),a("code",[e._v("make")]),e._v(" 来编译。")])])}),[],!1,null,null,null);t.default=v.exports}}]);