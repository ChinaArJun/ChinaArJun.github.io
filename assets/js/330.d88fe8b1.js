(window.webpackJsonp=window.webpackJsonp||[]).push([[330],{908:function(t,a,n){"use strict";n.r(a);var e=n(44),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_7-5-为什么遍历-go-map-是无序的？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-为什么遍历-go-map-是无序的？"}},[t._v("#")]),t._v(" 7.5 为什么遍历 Go map 是无序的？")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://wx2.sinaimg.cn/large/006fVPCvly1g1s1ah84k8j30k70dvaac.jpg",alt:"image"}})]),t._v(" "),n("p",[t._v("有的小伙伴没留意过 Go map 输出顺序，以为它是稳定的有序的；有的小伙伴知道是无序的，但却不知道为什么？有的却理解错误？今天我们将通过本文，揭开 "),n("code",[t._v("for range map")]),t._v(" 的 “神秘” 面纱，看看它内部实现到底是怎么样的，输出顺序到底是怎么样？")]),t._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func main() {\n\tm := make(map[int32]string)\n\tm[0] = "EDDYCJY1"\n\tm[1] = "EDDYCJY2"\n\tm[2] = "EDDYCJY3"\n\tm[3] = "EDDYCJY4"\n\tm[4] = "EDDYCJY5"\n\n\tfor k, v := range m {\n\t\tlog.Printf("k: %v, v: %v", k, v)\n\t}\n}\n')])])]),n("p",[t._v("假设运行这段代码，输出结果是按顺序？还是无序输出呢？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("2019/04/03 23:27:29 k: 3, v: EDDYCJY4\n2019/04/03 23:27:29 k: 4, v: EDDYCJY5\n2019/04/03 23:27:29 k: 0, v: EDDYCJY1\n2019/04/03 23:27:29 k: 1, v: EDDYCJY2\n2019/04/03 23:27:29 k: 2, v: EDDYCJY3\n")])])]),n("p",[t._v("从输出结果上来讲，是非固定顺序输出的，也就是每次都不一样（标题也讲了）。但这是为什么呢？")]),t._v(" "),n("p",[t._v("首先"),n("strong",[t._v("建议你先自己想想原因")]),t._v("。其次我在面试时听过一些说法。有人说因为是哈希的所以就是无（乱）序等等说法。当时我是有点 ？？？")]),t._v(" "),n("p",[t._v("这也是这篇文章出现的原因，希望大家可以一起研讨一下，理清这个问题 ：）")]),t._v(" "),n("h2",{attrs:{id:"看一下汇编"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#看一下汇编"}},[t._v("#")]),t._v(" 看一下汇编")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    ...\n\t0x009b 00155 (main.go:11)\tLEAQ\ttype.map[int32]string(SB), AX\n\t0x00a2 00162 (main.go:11)\tPCDATA\t$2, $0\n\t0x00a2 00162 (main.go:11)\tMOVQ\tAX, (SP)\n\t0x00a6 00166 (main.go:11)\tPCDATA\t$2, $2\n\t0x00a6 00166 (main.go:11)\tLEAQ\t""..autotmp_3+24(SP), AX\n\t0x00ab 00171 (main.go:11)\tPCDATA\t$2, $0\n\t0x00ab 00171 (main.go:11)\tMOVQ\tAX, 8(SP)\n\t0x00b0 00176 (main.go:11)\tPCDATA\t$2, $2\n\t0x00b0 00176 (main.go:11)\tLEAQ\t""..autotmp_2+72(SP), AX\n\t0x00b5 00181 (main.go:11)\tPCDATA\t$2, $0\n\t0x00b5 00181 (main.go:11)\tMOVQ\tAX, 16(SP)\n\t0x00ba 00186 (main.go:11)\tCALL\truntime.mapiterinit(SB)\n\t0x00bf 00191 (main.go:11)\tJMP\t207\n\t0x00c1 00193 (main.go:11)\tPCDATA\t$2, $2\n\t0x00c1 00193 (main.go:11)\tLEAQ\t""..autotmp_2+72(SP), AX\n\t0x00c6 00198 (main.go:11)\tPCDATA\t$2, $0\n\t0x00c6 00198 (main.go:11)\tMOVQ\tAX, (SP)\n\t0x00ca 00202 (main.go:11)\tCALL\truntime.mapiternext(SB)\n\t0x00cf 00207 (main.go:11)\tCMPQ\t""..autotmp_2+72(SP), $0\n\t0x00d5 00213 (main.go:11)\tJNE\t193\n\t...\n')])])]),n("p",[t._v("我们大致看一下整体过程，重点处理 Go map 循环迭代的是两个 runtime 方法，如下：")]),t._v(" "),n("ul",[n("li",[t._v("runtime.mapiterinit")]),t._v(" "),n("li",[t._v("runtime.mapiternext")])]),t._v(" "),n("p",[t._v("但你可能会想，明明用的是 "),n("code",[t._v("for range")]),t._v(" 进行循环迭代，怎么出现了这两个函数，怎么回事？")]),t._v(" "),n("h2",{attrs:{id:"看一下转换后"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#看一下转换后"}},[t._v("#")]),t._v(" 看一下转换后")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var hiter map_iteration_struct\nfor mapiterinit(type, range, &hiter); hiter.key != nil; mapiternext(&hiter) {\n    index_temp = *hiter.key\n    value_temp = *hiter.val\n    index = index_temp\n    value = value_temp\n    original body\n}\n")])])]),n("p",[t._v("实际上编译器对于 slice 和 map 的循环迭代有不同的实现方式，并不是 "),n("code",[t._v("for")]),t._v(" 一扔就完事了，还做了一些附加动作进行处理。而上述代码就是 "),n("code",[t._v("for range map")]),t._v(" 在编译器展开后的伪实现")]),t._v(" "),n("h2",{attrs:{id:"看一下源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#看一下源码"}},[t._v("#")]),t._v(" 看一下源码")]),t._v(" "),n("h3",{attrs:{id:"runtime-mapiterinit"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runtime-mapiterinit"}},[t._v("#")]),t._v(" runtime.mapiterinit")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func mapiterinit(t *maptype, h *hmap, it *hiter) {\n\t...\n\tit.t = t\n\tit.h = h\n\tit.B = h.B\n\tit.buckets = h.buckets\n\tif t.bucket.kind&kindNoPointers != 0 {\n\t\th.createOverflow()\n\t\tit.overflow = h.extra.overflow\n\t\tit.oldoverflow = h.extra.oldoverflow\n\t}\n\n\tr := uintptr(fastrand())\n\tif h.B > 31-bucketCntBits {\n\t\tr += uintptr(fastrand()) << 31\n\t}\n\tit.startBucket = r & bucketMask(h.B)\n\tit.offset = uint8(r >> h.B & (bucketCnt - 1))\n\tit.bucket = it.startBucket\n    ...\n\n\tmapiternext(it)\n}\n")])])]),n("p",[t._v("通过对 "),n("code",[t._v("mapiterinit")]),t._v(" 方法阅读，可得知其主要用途是在 map 进行遍历迭代时"),n("strong",[t._v("进行初始化动作")]),t._v("。共有三个形参，用于读取当前哈希表的类型信息、当前哈希表的存储信息和当前遍历迭代的数据")]),t._v(" "),n("h4",{attrs:{id:"为什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么"}},[t._v("#")]),t._v(" 为什么")]),t._v(" "),n("p",[t._v("咱们关注到源码中 "),n("code",[t._v("fastrand")]),t._v(" 的部分，这个方法名，是不是迷之眼熟。没错，它是一个生成随机数的方法。再看看上下文：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("...\n// decide where to start\nr := uintptr(fastrand())\nif h.B > 31-bucketCntBits {\n\tr += uintptr(fastrand()) << 31\n}\nit.startBucket = r & bucketMask(h.B)\nit.offset = uint8(r >> h.B & (bucketCnt - 1))\n\n// iterator state\nit.bucket = it.startBucket\n")])])]),n("p",[t._v("在这段代码中，它生成了随机数。用于决定从哪里开始循环迭代。更具体的话就是根据随机数，选择一个桶位置作为起始点进行遍历迭代")]),t._v(" "),n("p",[t._v("因此每次重新 "),n("code",[t._v("for range map")]),t._v("，你见到的结果都是不一样的。那是因为它的起始位置根本就不固定！")]),t._v(" "),n("h3",{attrs:{id:"runtime-mapiternext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#runtime-mapiternext"}},[t._v("#")]),t._v(" runtime.mapiternext")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func mapiternext(it *hiter) {\n    ...\n    for ; i < bucketCnt; i++ {\n\t\t...\n\t\tk := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))\n\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))\n\t\t...\n\t\tif (b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY) ||\n\t\t\t!(t.reflexivekey || alg.equal(k, k)) {\n\t\t\t...\n\t\t\tit.key = k\n\t\t\tit.value = v\n\t\t} else {\n\t\t\trk, rv := mapaccessK(t, h, k)\n\t\t\tif rk == nil {\n\t\t\t\tcontinue // key has been deleted\n\t\t\t}\n\t\t\tit.key = rk\n\t\t\tit.value = rv\n\t\t}\n\t\tit.bucket = bucket\n\t\tif it.bptr != b { \n\t\t\tit.bptr = b\n\t\t}\n\t\tit.i = i + 1\n\t\tit.checkBucket = checkBucket\n\t\treturn\n\t}\n\tb = b.overflow(t)\n\ti = 0\n\tgoto next\n}\n")])])]),n("p",[t._v("在上小节中，咱们已经选定了起始桶的位置。接下来就是通过 "),n("code",[t._v("mapiternext")]),t._v(" 进行"),n("strong",[t._v("具体的循环遍历动作")]),t._v("。该方法主要涉及如下：")]),t._v(" "),n("ul",[n("li",[t._v("从已选定的桶中开始进行遍历，寻找桶中的下一个元素进行处理")]),t._v(" "),n("li",[t._v("如果桶已经遍历完，则对溢出桶 "),n("code",[t._v("overflow buckets")]),t._v(" 进行遍历处理")])]),t._v(" "),n("p",[t._v("通过对本方法的阅读，可得知其对 buckets 的"),n("strong",[t._v("遍历规则")]),t._v("以及对于扩容的一些处理（这不是本文重点。因此没有具体展开）")]),t._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("在本文开始，咱们先提出核心讨论点：“为什么 Go map 遍历输出是不固定顺序？”。而通过这一番分析，原因也很简单明了。就是 "),n("code",[t._v("for range map")]),t._v(" 在开始处理循环逻辑的时候，就做了随机播种...")]),t._v(" "),n("p",[t._v("你想问为什么要这么做？当然是官方有意为之，因为 Go 在早期（1.0）的时候，虽是稳定迭代的，但从结果来讲，其实是无法保证每个 Go 版本迭代遍历规则都是一样的。而这将会导致可移植性问题。因此，改之。也请不要依赖...")]),t._v(" "),n("h2",{attrs:{id:"参考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://blog.golang.org/go-maps-in-action",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go maps in action"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);