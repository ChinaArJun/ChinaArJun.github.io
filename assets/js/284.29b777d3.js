(window.webpackJsonp=window.webpackJsonp||[]).push([[284],{862:function(e,t,a){"use strict";a.r(t);var r=a(44),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"go1-13-defer-的性能是如何提高的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-13-defer-的性能是如何提高的？"}},[e._v("#")]),e._v(" Go1.13 defer 的性能是如何提高的？")]),e._v(" "),a("p",[e._v("最近 Go1.13 终于发布了，其中一个值得关注的特性就是 "),a("strong",[e._v("defer 在大部分的场景下性能提升了30%")]),e._v("，但是官方并没有具体写是怎么提升的，这让大家非常的疑惑。而我因为之前写过"),a("a",{attrs:{href:"https://book.eddycjy.com/golang/defer/defer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《深入理解 Go defer》"),a("OutboundLink")],1),e._v(" 和 "),a("a",{attrs:{href:"https://book.eddycjy.com/golang/talk/defer-loss.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《Go defer 会有性能损耗，尽量不要用？》"),a("OutboundLink")],1),e._v(" 这类文章，因此我挺感兴趣它是做了什么改变才能得到这样子的结果，所以今天和大家一起探索其中奥妙。")]),e._v(" "),a("h2",{attrs:{id:"一、测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、测试"}},[e._v("#")]),e._v(" 一、测试")]),e._v(" "),a("h3",{attrs:{id:"go1-12"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-12"}},[e._v("#")]),e._v(" Go1.12")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go test -bench=. -benchmem -run=none\ngoos: darwin\ngoarch: amd64\npkg: github.com/EDDYCJY/awesomeDefer\nBenchmarkDoDefer-4      \t20000000\t        91.4 ns/op\t      48 B/op\t       1 allocs/op\nBenchmarkDoNotDefer-4   \t30000000\t        41.6 ns/op\t      48 B/op\t       1 allocs/op\nPASS\nok  \tgithub.com/EDDYCJY/awesomeDefer\t3.234s\n")])])]),a("h3",{attrs:{id:"go1-13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go1-13"}},[e._v("#")]),e._v(" Go1.13")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("$ go test -bench=. -benchmem -run=none\ngoos: darwin\ngoarch: amd64\npkg: github.com/EDDYCJY/awesomeDefer\nBenchmarkDoDefer-4      \t15986062\t        74.7 ns/op\t      48 B/op\t       1 allocs/op\nBenchmarkDoNotDefer-4   \t29231842\t        40.3 ns/op\t      48 B/op\t       1 allocs/op\nPASS\nok  \tgithub.com/EDDYCJY/awesomeDefer\t3.444s\n")])])]),a("p",[e._v("在开场，我先以不标准的测试基准验证了先前的测试用例，确确实实在这两个版本中，"),a("code",[e._v("defer")]),e._v(" 的性能得到了提高，但是看上去似乎不是百分百提高 30 %。")]),e._v(" "),a("h2",{attrs:{id:"二、看一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、看一下"}},[e._v("#")]),e._v(" 二、看一下")]),e._v(" "),a("h3",{attrs:{id:"之前（go1-12）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#之前（go1-12）"}},[e._v("#")]),e._v(" 之前（Go1.12）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    0x0070 00112 (main.go:6)    CALL    runtime.deferproc(SB)\n    0x0075 00117 (main.go:6)    TESTL    AX, AX\n    0x0077 00119 (main.go:6)    JNE    137\n    0x0079 00121 (main.go:7)    XCHGL    AX, AX\n    0x007a 00122 (main.go:7)    CALL    runtime.deferreturn(SB)\n    0x007f 00127 (main.go:7)    MOVQ    56(SP), BP\n")])])]),a("h3",{attrs:{id:"现在（go1-13）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#现在（go1-13）"}},[e._v("#")]),e._v(" 现在（Go1.13）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\t0x006e 00110 (main.go:4)\tMOVQ\tAX, (SP)\n\t0x0072 00114 (main.go:4)\tCALL\truntime.deferprocStack(SB)\n\t0x0077 00119 (main.go:4)\tTESTL\tAX, AX\n\t0x0079 00121 (main.go:4)\tJNE\t139\n\t0x007b 00123 (main.go:7)\tXCHGL\tAX, AX\n\t0x007c 00124 (main.go:7)\tCALL\truntime.deferreturn(SB)\n\t0x0081 00129 (main.go:7)\tMOVQ\t112(SP), BP\n")])])]),a("p",[e._v("从汇编的角度来看，像是 "),a("code",[e._v("runtime.deferproc")]),e._v(" 改成了 "),a("code",[e._v("runtime.deferprocStack")]),e._v(" 调用，难道是做了什么优化，我们"),a("strong",[e._v("抱着疑问")]),e._v("继续看下去。")]),e._v(" "),a("h2",{attrs:{id:"三、观察源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、观察源码"}},[e._v("#")]),e._v(" 三、观察源码")]),e._v(" "),a("h3",{attrs:{id:"defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[e._v("#")]),e._v(" _defer")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type _defer struct {\n\tsiz     int32\n\tsiz     int32 // includes both arguments and results\n\tstarted bool\n\theap    bool\n\tsp      uintptr // sp at time of defer\n\tpc      uintptr\n\tfn      *funcval\n\t...\n")])])]),a("p",[e._v("相较于以前的版本，最小单元的 "),a("code",[e._v("_defer")]),e._v(" 结构体主要是新增了 "),a("code",[e._v("heap")]),e._v(" 字段，用于标识这个 "),a("code",[e._v("_defer")]),e._v(" 是在堆上，还是在栈上进行分配，其余字段并没有明确变更，那我们可以把聚焦点放在 "),a("code",[e._v("defer")]),e._v(" 的堆栈分配上了，看看是做了什么事。")]),e._v(" "),a("h3",{attrs:{id:"deferprocstack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deferprocstack"}},[e._v("#")]),e._v(" deferprocStack")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('func deferprocStack(d *_defer) {\n\tgp := getg()\n\tif gp.m.curg != gp {\n\t\tthrow("defer on system stack")\n\t}\n\t\n\td.started = false\n\td.heap = false\n\td.sp = getcallersp()\n\td.pc = getcallerpc()\n\n\t*(*uintptr)(unsafe.Pointer(&d._panic)) = 0\n\t*(*uintptr)(unsafe.Pointer(&d.link)) = uintptr(unsafe.Pointer(gp._defer))\n\t*(*uintptr)(unsafe.Pointer(&gp._defer)) = uintptr(unsafe.Pointer(d))\n\n\treturn0()\n}\n')])])]),a("p",[e._v("这一块代码挺常规的，主要是获取调用 "),a("code",[e._v("defer")]),e._v(" 函数的函数栈指针、传入函数的参数具体地址以及PC（程序计数器），这块在前文 "),a("a",{attrs:{href:"https://book.eddycjy.com/golang/defer/defer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("《深入理解 Go defer》"),a("OutboundLink")],1),e._v(" 有详细介绍过，这里就不再赘述了。")]),e._v(" "),a("p",[e._v("那这个 "),a("code",[e._v("deferprocStack")]),e._v(" 特殊在哪呢，我们可以看到它把 "),a("code",[e._v("d.heap")]),e._v(" 设置为了 "),a("code",[e._v("false")]),e._v("，也就是代表 "),a("code",[e._v("deferprocStack")]),e._v(" 方法是针对将 "),a("code",[e._v("_defer")]),e._v(" 分配在栈上的应用场景的。")]),e._v(" "),a("h3",{attrs:{id:"deferproc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deferproc"}},[e._v("#")]),e._v(" deferproc")]),e._v(" "),a("p",[e._v("那么问题来了，它又在哪里处理分配到堆上的应用场景呢？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func newdefer(siz int32) *_defer {\n\t...\n\td.heap = true\n\td.link = gp._defer\n\tgp._defer = d\n\treturn d\n}\n")])])]),a("p",[e._v("那么 "),a("code",[e._v("newdefer")]),e._v(" 是在哪里调用的呢，如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn\n\t...\n\tsp := getcallersp()\n\targp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)\n\tcallerpc := getcallerpc()\n\n\td := newdefer(siz)\n\t...\n}\n")])])]),a("p",[e._v("非常明确，先前的版本中调用的 "),a("code",[e._v("deferproc")]),e._v(" 方法，现在被用于对应分配到堆上的场景了。")]),e._v(" "),a("h3",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("ul",[a("li",[e._v("第一点：可以确定的是 "),a("code",[e._v("deferproc")]),e._v(" 并没有被去掉，而是流程被优化了。")]),e._v(" "),a("li",[e._v("第二点：编译器会根据应用场景去选择使用 "),a("code",[e._v("deferproc")]),e._v(" 还是 "),a("code",[e._v("deferprocStack")]),e._v(" 方法，他们分别是针对分配在堆上和栈上的使用场景。")])]),e._v(" "),a("h2",{attrs:{id:"四、编译器如何选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、编译器如何选择"}},[e._v("#")]),e._v(" 四、编译器如何选择")]),e._v(" "),a("h3",{attrs:{id:"esc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#esc"}},[e._v("#")]),e._v(" esc")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// src/cmd/compile/internal/gc/esc.go\ncase ODEFER:\n\tif e.loopdepth == 1 { // top level\n\t\tn.Esc = EscNever // force stack allocation of defer record (see ssa.go)\n\t\tbreak\n\t}\n")])])]),a("h3",{attrs:{id:"ssa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssa"}},[e._v("#")]),e._v(" ssa")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// src/cmd/compile/internal/gc/ssa.go\ncase ODEFER:\n\td := callDefer\n\tif n.Esc == EscNever {\n\t\td = callDeferStack\n\t}\n    s.call(n.Left, d)\n")])])]),a("h3",{attrs:{id:"小结-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("p",[e._v("这块结合来看，核心就是当 "),a("code",[e._v("e.loopdepth == 1")]),e._v(" 时，会将逃逸分析结果 "),a("code",[e._v("n.Esc")]),e._v(" 设置为 "),a("code",[e._v("EscNever")]),e._v("，也就是将 "),a("code",[e._v("_defer")]),e._v(" 分配到栈上，那这个 "),a("code",[e._v("e.loopdepth")]),e._v(" 到底又是何方神圣呢，我们再详细看看代码，如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// src/cmd/compile/internal/gc/esc.go\ntype NodeEscState struct {\n\tCurfn             *Node\n\tFlowsrc           []EscStep \n\tRetval            Nodes    \n\tLoopdepth         int32  \n\tLevel             Level\n\tWalkgen           uint32\n\tMaxextraloopdepth int32\n}\n")])])]),a("p",[e._v("这里重点查看 "),a("code",[e._v("Loopdepth")]),e._v(" 字段，目前它共有三个值标识，分别是:")]),e._v(" "),a("ul",[a("li",[e._v("-1：全局。")]),e._v(" "),a("li",[e._v("0：返回变量。")]),e._v(" "),a("li",[e._v("1：顶级函数，又或是内部函数的不断增长值。")])]),e._v(" "),a("p",[e._v("这个读起来有点绕，结合我们上述 "),a("code",[e._v("e.loopdepth == 1")]),e._v(" 的表述来看，也就是当 "),a("code",[e._v("defer func")]),e._v(" 是顶级函数时，将会分配到栈上。但是若在  "),a("code",[e._v("defer func")]),e._v(" 外层出现显式的迭代循环，又或是出现隐式迭代，将会分配到堆上。其实深层表示的还是迭代深度的意思，我们可以来证实一下刚刚说的方向，显式迭代的代码如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('func main() {\n\tfor p := 0; p < 10; p++ {\n\t\tdefer func() {\n\t\t\tfor i := 0; i < 20; i++ {\n\t\t\t\tlog.Println("EDDYCJY")\n\t\t\t}\n\t\t}()\n\t}\n}\n')])])]),a("p",[e._v("查看汇编情况：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('$ go tool compile -S main.go\n"".main STEXT size=122 args=0x0 locals=0x20\n\t0x0000 00000 (main.go:15)\tTEXT\t"".main(SB), ABIInternal, $32-0\n\t...\n\t0x0048 00072 (main.go:17)\tCALL\truntime.deferproc(SB)\n\t0x004d 00077 (main.go:17)\tTESTL\tAX, AX\n\t0x004f 00079 (main.go:17)\tJNE\t83\n\t0x0051 00081 (main.go:17)\tJMP\t33\n\t0x0053 00083 (main.go:17)\tXCHGL\tAX, AX\n\t0x0054 00084 (main.go:17)\tCALL\truntime.deferreturn(SB)\n\t...\n')])])]),a("p",[e._v("显然，最终 "),a("code",[e._v("defer")]),e._v(" 调用的是 "),a("code",[e._v("runtime.deferproc")]),e._v(" 方法，也就是分配到堆上了，没毛病。而隐式迭代的话，你可以借助 "),a("code",[e._v("goto")]),e._v(" 语句去实现这个功能，再自己验证一遍，这里就不再赘述了。")]),e._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[e._v("从分析的结果上来看，官方说明的 Go1.13 defer 性能提高 30%，主要来源于其延迟对象的堆栈分配规则的改变，措施是由编译器通过对 "),a("code",[e._v("defer")]),e._v(" 的 "),a("code",[e._v("for-loop")]),e._v(" 迭代深度进行分析，如果 "),a("code",[e._v("loopdepth")]),e._v(" 为 1，则设置逃逸分析的结果，将分配到栈上，否则分配到堆上。")]),e._v(" "),a("p",[e._v("的确，我个人觉得对大部分的使用场景来讲，是优化了不少，也解决了一些人吐槽 "),a("code",[e._v("defer")]),e._v(" 性能 “差” 的问题。另外，我想从 Go1.13 起，你也需要稍微了解一下它这块的机制，别随随便便就来个狂野版嵌套迭代 "),a("code",[e._v("defer")]),e._v("，可能没法效能最大化。")]),e._v(" "),a("p",[e._v("如果你还想了解更多细节，可以看看 "),a("code",[e._v("defer")]),e._v(" 这块的的"),a("a",{attrs:{href:"https://github.com/golang/go/commit/fff4f599fe1c21e411a99de5c9b3777d06ce0ce6",target:"_blank",rel:"noopener noreferrer"}},[e._v("提交内容"),a("OutboundLink")],1),e._v("，官方的测试用例也包含在里面。")])])}),[],!1,null,null,null);t.default=n.exports}}]);