(window.webpackJsonp=window.webpackJsonp||[]).push([[556],{1153:function(t,e,a){"use strict";a.r(e);var n=a(44),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("接口定义了一种规范，描述了类的行为和功能，而不做具体实现。")]),t._v(" "),a("p",[t._v('C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的。例如：')]),t._v(" "),a("div",{staticClass:"language-C++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Shape\n{\n   public:\n      // 纯虚函数\n      virtual double getArea() = 0;\n   private:\n      string name;      // 名称\n};\n")])])]),a("p",[t._v("设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。")]),t._v(" "),a("p",[t._v("派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。")]),t._v(" "),a("p",[t._v("C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。")]),t._v(" "),a("p",[t._v("C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 "),a("code",[t._v("itab")]),t._v(" 中的 "),a("code",[t._v("fun")]),t._v(" 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 "),a("code",[t._v("itab")]),t._v(" 中的 "),a("code",[t._v("fun")]),t._v(" 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 "),a("code",[t._v("itab")]),t._v("， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。")]),t._v(" "),a("h1",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("p",[t._v("【和 C++ 的对比】https://www.jianshu.com/p/b38b1719636e")])])}),[],!1,null,null,null);e.default=v.exports}}]);