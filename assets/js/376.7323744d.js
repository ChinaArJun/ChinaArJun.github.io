(window.webpackJsonp=window.webpackJsonp||[]).push([[376],{955:function(t,n,e){"use strict";e.r(n);var o=e(44),i=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("G、P、M 是 Go 调度器的三个核心组件，各司其职。在它们精密地配合下，Go 调度器得以高效运转，这也是 Go 天然支持高并发的内在动力。今天这篇文章我们来深入理解 GPM 模型。")]),t._v(" "),e("p",[t._v("先看 G，取 goroutine 的首字母，主要保存 goroutine 的一些状态信息以及 CPU 的一些寄存器的值，例如 IP 寄存器，以便在轮到本 goroutine 执行时，CPU 知道要从哪一条指令处开始执行。")]),t._v(" "),e("blockquote",[e("p",[t._v("当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。")])]),t._v(" "),e("blockquote",[e("p",[t._v("当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。")])]),t._v(" "),e("p",[t._v("本系列使用的代码版本是 1.9.2，来看一下 g 的源码：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type g struct {\n\n\t// goroutine 使用的栈\n\tstack       stack   // offset known to runtime/cgo\n\t// 用于栈的扩张和收缩检查，抢占标志\n\tstackguard0 uintptr // offset known to liblink\n\tstackguard1 uintptr // offset known to liblink\n\n\t_panic         *_panic // innermost panic - offset known to liblink\n\t_defer         *_defer // innermost defer\n\t// 当前与 g 绑定的 m\n\tm              *m      // current m; offset known to arm liblink\n\t// goroutine 的运行现场\n\tsched          gobuf\n\tsyscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc\n\tsyscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc\n\tstktopsp       uintptr        // expected sp at top of stack, to check in traceback\n\t// wakeup 时传入的参数\n\tparam          unsafe.Pointer // passed parameter on wakeup\n\tatomicstatus   uint32\n\tstackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus\n\tgoid           int64\n\t// g 被阻塞之后的近似时间\n\twaitsince      int64  // approx time when the g become blocked\n\t// g 被阻塞的原因\n\twaitreason     string // if status==Gwaiting\n\t// 指向全局队列里下一个 g\n\tschedlink      guintptr\n\t// 抢占调度标志。这个为 true 时，stackguard0 等于 stackpreempt\n\tpreempt        bool     // preemption signal, duplicates stackguard0 = stackpreempt\n\tpaniconfault   bool     // panic (instead of crash) on unexpected fault address\n\tpreemptscan    bool     // preempted g does scan for gc\n\tgcscandone     bool     // g has scanned stack; protected by _Gscan bit in status\n\tgcscanvalid    bool     // false at start of gc cycle, true if G has not run since last scan; TODO: remove?\n\tthrowsplit     bool     // must not split stack\n\traceignore     int8     // ignore race detection events\n\tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n\t// syscall 返回之后的 cputicks，用来做 tracing\n\tsysexitticks   int64    // cputicks when syscall has returned (for tracing)\n\ttraceseq       uint64   // trace event sequencer\n\ttracelastp     puintptr // last P emitted an event for this goroutine\n\t// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上\n\tlockedm        *m\n\tsig            uint32\n\twritebuf       []byte\n\tsigcode0       uintptr\n\tsigcode1       uintptr\n\tsigpc          uintptr\n\t// 创建该 goroutine 的语句的指令地址\n\tgopc           uintptr // pc of go statement that created this goroutine\n\t// goroutine 函数的指令地址\n\tstartpc        uintptr // pc of goroutine function\n\tracectx        uintptr\n\twaiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\n\tcgoCtxt        []uintptr      // cgo traceback context\n\tlabels         unsafe.Pointer // profiler labels\n\t// time.Sleep 缓存的定时器\n\ttimer          *timer         // cached timer for time.Sleep\n\n\tgcAssistBytes int64\n}\n")])])]),e("p",[t._v("源码中，比较重要的字段我已经作了注释，其他未作注释的与调度关系不大或者我暂时也没有理解的。")]),t._v(" "),e("p",[e("code",[t._v("g")]),t._v(" 结构体关联了两个比较简单的结构体，stack 表示 goroutine 运行时的栈：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 描述栈的数据结构，栈的范围：[lo, hi)\ntype stack struct {\n    // 栈顶，低地址\n\tlo uintptr\n\t// 栈低，高地址\n\thi uintptr\n}\n")])])]),e("p",[t._v("Goroutine 运行时，光有栈还不行，至少还得包括 PC，SP 等寄存器，gobuf 就保存了这些值：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type gobuf struct {\n\t// 存储 rsp 寄存器的值\n\tsp   uintptr\n\t// 存储 rip 寄存器的值\n\tpc   uintptr\n\t// 指向 goroutine\n\tg    guintptr\n\tctxt unsafe.Pointer // this has to be a pointer so that gc scans it\n\t// 保存系统调用的返回值\n\tret  sys.Uintreg\n\tlr   uintptr\n\tbp   uintptr // for GOEXPERIMENT=framepointer\n}\n")])])]),e("p",[t._v("再来看 M，取 machine 的首字母，它代表一个工作线程，或者说系统线程。G 需要调度到 M 上才能运行，M 是真正工作的人。结构体 m 就是我们常说的 M，它保存了 M 自身使用的栈信息、当前正在 M 上执行的 G 信息、与之绑定的 P 信息……")]),t._v(" "),e("p",[t._v("当 M 没有工作可做的时候，在它休眠前，会“自旋”地来找工作：检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作。")]),t._v(" "),e("p",[t._v("结构体 m 的源码如下：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// m 代表工作线程，保存了自身使用的栈信息\ntype m struct {\n\t// 记录工作线程（也就是内核线程）使用的栈信息。在执行调度代码时需要使用\n\t// 执行用户 goroutine 代码时，使用用户 goroutine 自己的栈，因此调度时会发生栈的切换\n\tg0      *g     // goroutine with scheduling stack/\n\tmorebuf gobuf  // gobuf arg to morestack\n\tdivmod  uint32 // div/mod denominator for arm - known to liblink\n\n\t// Fields not known to debuggers.\n\tprocid        uint64     // for debuggers, but offset not hard-coded\n\tgsignal       *g         // signal-handling g\n\tsigmask       sigset     // storage for saved signal mask\n\t// 通过 tls 结构体实现 m 与工作线程的绑定\n\t// 这里是线程本地存储\n\ttls           [6]uintptr // thread-local storage (for x86 extern register)\n\tmstartfn      func()\n\t// 指向正在运行的 gorutine 对象\n\tcurg          *g       // current running goroutine\n\tcaughtsig     guintptr // goroutine running during fatal signal\n\t// 当前工作线程绑定的 p\n\tp             puintptr // attached p for executing go code (nil if not executing go code)\n\tnextp         puintptr\n\tid            int32\n\tmallocing     int32\n\tthrowing      int32\n\t// 该字段不等于空字符串的话，要保持 curg 始终在这个 m 上运行\n\tpreemptoff    string // if != "", keep curg running on this m\n\tlocks         int32\n\tsoftfloat     int32\n\tdying         int32\n\tprofilehz     int32\n\thelpgc        int32\n\t// 为 true 时表示当前 m 处于自旋状态，正在从其他线程偷工作\n\tspinning      bool // m is out of work and is actively looking for work\n\t// m 正阻塞在 note 上\n\tblocked       bool // m is blocked on a note\n\t// m 正在执行 write barrier\n\tinwb          bool // m is executing a write barrier\n\tnewSigstack   bool // minit on C thread called sigaltstack\n\tprintlock     int8\n\t// 正在执行 cgo 调用\n\tincgo         bool // m is executing a cgo call\n\tfastrand      uint32\n\t// cgo 调用总计数\n\tncgocall      uint64      // number of cgo calls in total\n\tncgo          int32       // number of cgo calls currently in progress\n\tcgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n\tcgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n\t// 没有 goroutine 需要运行时，工作线程睡眠在这个 park 成员上，\n\t// 其它线程通过这个 park 唤醒该工作线程\n\tpark          note\n\t// 记录所有工作线程的链表\n\talllink       *m // on allm\n\tschedlink     muintptr\n\tmcache        *mcache\n\tlockedg       *g\n\tcreatestack   [32]uintptr // stack that created this thread.\n\tfreglo        [16]uint32  // d[i] lsb and f[i]\n\tfreghi        [16]uint32  // d[i] msb and f[i+16]\n\tfflag         uint32      // floating point compare flags\n\tlocked        uint32      // tracking for lockosthread\n\t// 正在等待锁的下一个 m\n\tnextwaitm     uintptr     // next m waiting for lock\n\tneedextram    bool\n\ttraceback     uint8\n\twaitunlockf   unsafe.Pointer // todo go func(*g, unsafe.pointer) bool\n\twaitlock      unsafe.Pointer\n\twaittraceev   byte\n\twaittraceskip int\n\tstartingtrace bool\n\tsyscalltick   uint32\n\t// 工作线程 id\n\tthread        uintptr // thread handle\n\n\t// these are here because they are too large to be on the stack\n\t// of low-level NOSPLIT functions.\n\tlibcall   libcall\n\tlibcallpc uintptr // for cpu profiler\n\tlibcallsp uintptr\n\tlibcallg  guintptr\n\tsyscall   libcall // stores syscall parameters on windows\n\n\tmOS\n}\n')])])]),e("p",[t._v("再来看 P，取 processor 的首字母，为 M 的执行提供“上下文”，保存 M 执行 G 时的一些资源，例如本地可运行 G 队列，memeory cache 等。")]),t._v(" "),e("p",[t._v("一个 M 只有绑定 P 才能执行 goroutine，当 M 被阻塞时，整个 P 会被传递给其他 M ，或者说整个 P 被接管。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// p 保存 go 运行时所必须的资源\ntype p struct {\n\tlock mutex\n\n\t// 在 allp 中的索引\n\tid          int32\n\tstatus      uint32 // one of pidle/prunning/...\n\tlink        puintptr\n\t// 每次调用 schedule 时会加一\n\tschedtick   uint32\n\t// 每次系统调用时加一\n\tsyscalltick uint32\n\t// 用于 sysmon 线程记录被监控 p 的系统调用时间和运行时间\n\tsysmontick  sysmontick // last tick observed by sysmon\n\t// 指向绑定的 m，如果 p 是 idle 的话，那这个指针是 nil\n\tm           muintptr   // back-link to associated m (nil if idle)\n\tmcache      *mcache\n\tracectx     uintptr\n\n\tdeferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n\tdeferpoolbuf [5][32]*_defer\n\n\t// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.\n\tgoidcache    uint64\n\tgoidcacheend uint64\n\n\t// Queue of runnable goroutines. Accessed without lock.\n\t// 本地可运行的队列，不用通过锁即可访问\n\trunqhead uint32 // 队列头\n\trunqtail uint32 // 队列尾\n\t// 使用数组实现的循环队列\n\trunq     [256]guintptr\n\t\n\t// runnext 非空时，代表的是一个 runnable 状态的 G，\n\t// 这个 G 被 当前 G 修改为 ready 状态，相比 runq 中的 G 有更高的优先级。\n\t// 如果当前 G 还有剩余的可用时间，那么就应该运行这个 G\n\t// 运行之后，该 G 会继承当前 G 的剩余时间\n\trunnext guintptr\n\n\t// Available G's (status == Gdead)\n\t// 空闲的 g\n\tgfree    *g\n\tgfreecnt int32\n\n\tsudogcache []*sudog\n\tsudogbuf   [128]*sudog\n\n\ttracebuf traceBufPtr\n\ttraceSwept, traceReclaimed uintptr\n\n\tpalloc persistentAlloc // per-P to avoid mutex\n\n\t// Per-P GC state\n\tgcAssistTime     int64 // Nanoseconds in assistAlloc\n\tgcBgMarkWorker   guintptr\n\tgcMarkWorkerMode gcMarkWorkerMode\n\trunSafePointFn uint32 // if 1, run sched.safePointFn at next safe point\n\n\tpad [sys.CacheLineSize]byte\n}\n")])])]),e("p",[t._v("GPM 三足鼎力，共同成就 Go scheduler。G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G。你中有我，我中有你。")]),t._v(" "),e("p",[t._v("描述三者的关系：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/63308368-eb928d80-c324-11e9-989d-71af7d03bece.png",alt:"曹大 golang notes GPM 三者关系"}})]),t._v(" "),e("p",[t._v("M 会从与它绑定的 P 的本地队列获取可运行的 G，也会从 network poller 里获取可运行的 G，还会从其他 P 偷 G。")]),t._v(" "),e("p",[t._v("最后我们从宏观上总结一下 GPM，这篇文章尝试从它们的状态流转角度总结。")]),t._v(" "),e("p",[t._v("首先是 G 的状态流转：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/64057782-d98dd600-cbd3-11e9-918d-8320fd9609c0.png",alt:"G 的状态流转图"}})]),t._v(" "),e("p",[t._v("说明一下，上图省略了一些垃圾回收的状态。")]),t._v(" "),e("p",[t._v("接着是 P 的状态流转：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/64058164-93d40c00-cbd9-11e9-9095-7bc7248a0fb9.png",alt:"P 的状态流转图"}})]),t._v(" "),e("blockquote",[e("p",[t._v("通常情况下（在程序运行时不调整 P 的个数），P 只会在上图中的四种状态下进行切换。 当程序刚开始运行进行初始化时，所有的 P 都处于 "),e("code",[t._v("_Pgcstop")]),t._v(" 状态， 随着 P 的初始化（"),e("code",[t._v("runtime.procresize")]),t._v("），会被置于 "),e("code",[t._v("_Pidle")]),t._v("。")])]),t._v(" "),e("blockquote",[e("p",[t._v("当 M 需要运行时，会 "),e("code",[t._v("runtime.acquirep")]),t._v(" 来使 P 变成 "),e("code",[t._v("Prunning")]),t._v(" 状态，并通过 "),e("code",[t._v("runtime.releasep")]),t._v(" 来释放。")])]),t._v(" "),e("blockquote",[e("p",[t._v("当 G 执行时需要进入系统调用，P 会被设置为 "),e("code",[t._v("_Psyscall")]),t._v("， 如果这个时候被系统监控抢夺（"),e("code",[t._v("runtime.retake")]),t._v("），则 P 会被重新修改为 "),e("code",[t._v("_Pidle")]),t._v("。")])]),t._v(" "),e("blockquote",[e("p",[t._v("如果在程序运行中发生 "),e("code",[t._v("GC")]),t._v("，则 P 会被设置为 "),e("code",[t._v("_Pgcstop")]),t._v("， 并在 "),e("code",[t._v("runtime.startTheWorld")]),t._v(" 时重新调整为 "),e("code",[t._v("_Prunning")]),t._v("。")])]),t._v(" "),e("p",[t._v("最后，我们来看 M 的状态变化：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/64058333-09d97280-cbdc-11e9-8a4d-1843d5be88d0.png",alt:"M 的状态流转图"}})]),t._v(" "),e("p",[t._v("M 只有自旋和非自旋两种状态。自旋的时候，会努力找工作；找不到的时候会进入非自旋状态，之后会休眠，直到有工作需要处理时，被其他工作线程唤醒，又进入自旋状态。")])])}),[],!1,null,null,null);n.default=i.exports}}]);