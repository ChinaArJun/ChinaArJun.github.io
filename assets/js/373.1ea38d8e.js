(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{952:function(n,t,e){"use strict";e.r(t);var c=e(44),a=Object(c.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[n._v("#")]),n._v(" 源码分析")]),n._v(" "),e("p",[n._v("发送操作最终转化为 "),e("code",[n._v("chansend")]),n._v(" 函数，直接上源码，同样大部分都注释了，可以看懂主流程：")]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 位于 src/runtime/chan.go\n\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n\t// 如果 channel 是 nil\n\tif c == nil {\n\t\t// 不能阻塞，直接返回 false，表示未发送成功\n\t\tif !block {\n\t\t\treturn false\n\t\t}\n\t\t// 当前 goroutine 被挂起\n\t\tgopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)\n\t\tthrow("unreachable")\n\t}\n\n\t// 省略 debug 相关……\n\n\t// 对于不阻塞的 send，快速检测失败场景\n\t//\n\t// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：\n\t// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine\n\t// 2. channel 是缓冲型的，但循环数组已经装满了元素\n\tif !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||\n\t\t(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {\n\t\treturn false\n\t}\n\n\tvar t0 int64\n\tif blockprofilerate > 0 {\n\t\tt0 = cputicks()\n\t}\n\n\t// 锁住 channel，并发安全\n\tlock(&c.lock)\n\n\t// 如果 channel 关闭了\n\tif c.closed != 0 {\n\t\t// 解锁\n\t\tunlock(&c.lock)\n\t\t// 直接 panic\n\t\tpanic(plainError("send on closed channel"))\n\t}\n\n\t// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine\n\tif sg := c.recvq.dequeue(); sg != nil {\n\t\tsend(c, sg, ep, func() { unlock(&c.lock) }, 3)\n\t\treturn true\n\t}\n\n\t// 对于缓冲型的 channel，如果还有缓冲空间\n\tif c.qcount < c.dataqsiz {\n\t\t// qp 指向 buf 的 sendx 位置\n\t\tqp := chanbuf(c, c.sendx)\n\n\t\t// ……\n\n\t\t// 将数据从 ep 处拷贝到 qp\n\t\ttypedmemmove(c.elemtype, qp, ep)\n\t\t// 发送游标值加 1\n\t\tc.sendx++\n\t\t// 如果发送游标值等于容量值，游标值归 0\n\t\tif c.sendx == c.dataqsiz {\n\t\t\tc.sendx = 0\n\t\t}\n\t\t// 缓冲区的元素数量加一\n\t\tc.qcount++\n\n\t\t// 解锁\n\t\tunlock(&c.lock)\n\t\treturn true\n\t}\n\n\t// 如果不需要阻塞，则直接返回错误\n\tif !block {\n\t\tunlock(&c.lock)\n\t\treturn false\n\t}\n\n\t// channel 满了，发送方会被阻塞。接下来会构造一个 sudog\n\n\t// 获取当前 goroutine 的指针\n\tgp := getg()\n\tmysg := acquireSudog()\n\tmysg.releasetime = 0\n\tif t0 != 0 {\n\t\tmysg.releasetime = -1\n\t}\n\n\tmysg.elem = ep\n\tmysg.waitlink = nil\n\tmysg.g = gp\n\tmysg.selectdone = nil\n\tmysg.c = c\n\tgp.waiting = mysg\n\tgp.param = nil\n\n\t// 当前 goroutine 进入发送等待队列\n\tc.sendq.enqueue(mysg)\n\n\t// 当前 goroutine 被挂起\n\tgoparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)\n\n\t// 从这里开始被唤醒了（channel 有机会可以发送了）\n\tif mysg != gp.waiting {\n\t\tthrow("G waiting list is corrupted")\n\t}\n\tgp.waiting = nil\n\tif gp.param == nil {\n\t\tif c.closed == 0 {\n\t\t\tthrow("chansend: spurious wakeup")\n\t\t}\n\t\t// 被唤醒后，channel 关闭了。坑爹啊，panic\n\t\tpanic(plainError("send on closed channel"))\n\t}\n\tgp.param = nil\n\tif mysg.releasetime > 0 {\n\t\tblockevent(mysg.releasetime-t0, 2)\n\t}\n\t// 去掉 mysg 上绑定的 channel\n\tmysg.c = nil\n\treleaseSudog(mysg)\n\treturn true\n}\n')])])]),e("p",[n._v("上面的代码注释地比较详细了，我们来详细看看。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("如果检测到 channel 是空的，当前 goroutine 会被挂起。")])]),n._v(" "),e("li",[e("p",[n._v("对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）")])])]),n._v(" "),e("p",[n._v("对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。")]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) || (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {\n\treturn false\n}\n")])])]),e("p",[n._v("注释里主要讲为什么这一块可以不加锁，我详细解释一下。"),e("code",[n._v("if")]),n._v(" 条件里先读了两个变量：block 和 c.closed。block 是函数的参数，不会变；c.closed 可能被其他 goroutine 改变，因为没加锁嘛，这是“与”条件前面两个表达式。")]),n._v(" "),e("p",[n._v("最后一项，涉及到三个变量：c.dataqsiz，c.recvq.first，c.qcount。"),e("code",[n._v("c.dataqsiz == 0 && c.recvq.first == nil")]),n._v(" 指的是非缓冲型的 channel，并且 recvq 里没有等待接收的 goroutine；"),e("code",[n._v("c.dataqsiz > 0 && c.qcount == c.dataqsiz")]),n._v(" 指的是缓冲型的 channel，但循环数组已经满了。这里 "),e("code",[n._v("c.dataqsiz")]),n._v(" 实际上也是不会被修改的，在创建的时候就已经确定了。不加锁真正影响地是 "),e("code",[n._v("c.qcount")]),n._v(" 和 "),e("code",[n._v("c.recvq.first")]),n._v("。")]),n._v(" "),e("p",[n._v("这一部分的条件就是两个 "),e("code",[n._v("word-sized read")]),n._v("，就是读两个 word 操作："),e("code",[n._v("c.closed")]),n._v(" 和 "),e("code",[n._v("c.recvq.first")]),n._v("（非缓冲型） 或者 "),e("code",[n._v("c.qcount")]),n._v("（缓冲型）。")]),n._v(" "),e("p",[n._v("当我们发现 "),e("code",[n._v("c.closed == 0")]),n._v(" 为真，也就是 channel 未被关闭，再去检测第三部分的条件时，观测到 "),e("code",[n._v("c.recvq.first == nil")]),n._v(" 或者 "),e("code",[n._v("c.qcount == c.dataqsiz")]),n._v(" 时（这里忽略 "),e("code",[n._v("c.dataqsiz")]),n._v("），就断定要将这次发送操作作失败处理，快速返回 false。")]),n._v(" "),e("p",[n._v("这里涉及到两个观测项：channel 未关闭、channel not ready for sending。这两项都会因为没加锁而出现观测前后不一致的情况。例如我先观测到 channel 未被关闭，再观察到 channel not ready for sending，这时我以为能满足这个 if 条件了，但是如果这时 c.closed 变成 1，这时其实就不满足条件了，谁让你不加锁呢！")]),n._v(" "),e("p",[n._v("但是，因为一个 closed channel 不能将 channel 状态从 'ready for sending' 变成 'not ready for sending'，所以当我观测到 'not ready for sending' 时，channel 不是 closed。即使 "),e("code",[n._v("c.closed == 1")]),n._v("，即 channel 是在这两个观测中间被关闭的，那也说明在这两个观测中间，channel 满足两个条件："),e("code",[n._v("not closed")]),n._v(" 和 "),e("code",[n._v("not ready for sending")]),n._v("，这时，我直接返回 false 也是没有问题的。")]),n._v(" "),e("p",[n._v("这部分解释地比较绕，其实这样做的目的就是少获取一次锁，提升性能。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("如果检测到 channel 已经关闭，直接 panic。")])]),n._v(" "),e("li",[e("p",[n._v("如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 "),e("code",[n._v("sendDirect")]),n._v(" 函数完成。")])])]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// send 函数处理向一个空的 channel 发送操作\n\n// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine\n// 之后，接收的 goroutine 会被唤醒\n// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）\n// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁\n// sg 必须已经从等待队列里取出来了\n// ep 必须是非空，并且它指向堆或调用者的栈\n\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {\n\t// 省略一些用不到的\n\t// ……\n\n\t// sg.elem 指向接收到的值存放的位置，如 val <- ch，指的就是 &val\n\tif sg.elem != nil {\n\t\t// 直接拷贝内存（从发送者到接收者）\n\t\tsendDirect(c.elemtype, sg, ep)\n\t\tsg.elem = nil\n\t}\n\t// sudog 上绑定的 goroutine\n\tgp := sg.g\n\t// 解锁\n\tunlockf()\n\tgp.param = unsafe.Pointer(sg)\n\tif sg.releasetime != 0 {\n\t\tsg.releasetime = cputicks()\n\t}\n\t// 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会\n\tgoready(gp, skip+1)\n}\n")])])]),e("p",[n._v("继续看 "),e("code",[n._v("sendDirect")]),n._v(" 函数：")]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel\n// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈\n// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写\n// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避\nfunc sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {\n\t// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈\n\n\t// 直接进行内存"搬迁"\n\t// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后\n\t// 就不能修改真正的 dst 位置的值了\n\t// 因此需要在读和写之前加上一个屏障\n\tdst := sg.elem\n\ttypeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)\n\tmemmove(dst, src, t.size)\n}\n')])])]),e("p",[n._v("这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。")]),n._v(" "),e("p",[n._v("然后，解锁、唤醒接收者，等待调度器的光临，接收者也得以重见天日，可以继续执行接收操作之后的代码了。")]),n._v(" "),e("ul",[e("li",[n._v("如果 "),e("code",[n._v("c.qcount < c.dataqsiz")]),n._v("，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：")])]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("qp := chanbuf(c, c.sendx)\n\n// 返回循环队列里第 i 个元素的地址处\nfunc chanbuf(c *hchan, i uint) unsafe.Pointer {\n\treturn add(c.buf, uintptr(i)*uintptr(c.elemsize))\n}\n")])])]),e("p",[e("code",[n._v("c.sendx")]),n._v(" 指向下一个待发送元素在循环数组中的位置，然后调用 "),e("code",[n._v("typedmemmove")]),n._v(" 函数将其拷贝到循环数组中。之后 "),e("code",[n._v("c.sendx")]),n._v(" 加 1，元素总量加 1 ："),e("code",[n._v("c.qcount++")]),n._v("，最后，解锁并返回。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。")])]),n._v(" "),e("li",[e("p",[n._v("最后就是真的需要被阻塞的情况。先构造一个 sudog，将其入队（channel 的 sendq 字段）。然后调用 "),e("code",[n._v("goparkunlock")]),n._v(" 将当前 goroutine 挂起，并解锁，等待合适的时机再唤醒。")])])]),n._v(" "),e("p",[n._v("唤醒之后，从 "),e("code",[n._v("goparkunlock")]),n._v(" 下一行代码开始继续往下执行。")]),n._v(" "),e("p",[n._v("这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 "),e("code",[n._v("elem")]),n._v(" 字段绑定待发送元素的地址，以及 "),e("code",[n._v("c")]),n._v(" 字段绑定被“坑”在此处的 channel。")]),n._v(" "),e("p",[n._v("所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。")]),n._v(" "),e("h1",{attrs:{id:"案例分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例分析"}},[n._v("#")]),n._v(" 案例分析")]),n._v(" "),e("p",[n._v("好了，看完源码。我们接着来分析例子，代码如下：")]),n._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('func goroutineA(a <-chan int) {\n\tval := <- a\n\tfmt.Println("goroutine A received data: ", val)\n\treturn\n}\n\nfunc goroutineB(b <-chan int) {\n\tval := <- b\n\tfmt.Println("goroutine B received data: ", val)\n\treturn\n}\n\nfunc main() {\n\tch := make(chan int)\n\tgo goroutineA(ch)\n\tgo goroutineB(ch)\n\tch <- 3\n\ttime.Sleep(time.Second)\n\n\tch1 := make(chan struct{})\n}\n')])])]),e("p",[n._v("在发送小节里我们说到 G1 和 G2 现在被挂起来了，等待 sender 的解救。在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。")]),n._v(" "),e("p",[n._v("根据前面源码分析的结果，我们知道，sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。")]),n._v(" "),e("p",[n._v("然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61342598-4bf16380-a87d-11e9-8667-c22b02030d6b.png",alt:"G1 runnable"}})]),n._v(" "),e("p",[n._v("当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。")]),n._v(" "),e("p",[n._v("这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61342620-64fa1480-a87d-11e9-8cac-eacd2f4892f8.png",alt:"send direct"}})]),n._v(" "),e("p",[n._v("上图是一个示意图，"),e("code",[n._v("3")]),n._v(" 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。")]),n._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[n._v("#")]),n._v(" 参考资料")]),n._v(" "),e("p",[n._v("【深入 channel 底层】https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8")]),n._v(" "),e("p",[n._v("【Kavya在Gopher Con 上关于 channel 的设计，非常好】https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf")])])}),[],!1,null,null,null);t.default=a.exports}}]);