(window.webpackJsonp=window.webpackJsonp||[]).push([[398],{977:function(t,n,e){"use strict";e.r(n);var a=e(44),i=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("通过前面提到的 "),e("code",[t._v("iface")]),t._v(" 的源码可以看到，实际上它包含接口的类型 "),e("code",[t._v("interfacetype")]),t._v(" 和 实体类型的类型 "),e("code",[t._v("_type")]),t._v("，这两者都是 "),e("code",[t._v("iface")]),t._v(" 的字段 "),e("code",[t._v("itab")]),t._v(" 的成员。也就是说生成一个 "),e("code",[t._v("itab")]),t._v(" 同时需要接口的类型和实体的类型。")]),t._v(" "),e("blockquote",[e("p",[t._v("<interface 类型， 实体类型> ->itable")])]),t._v(" "),e("p",[t._v("当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。")]),t._v(" "),e("p",[t._v("例如某类型有 "),e("code",[t._v("m")]),t._v(" 个方法，某接口有 "),e("code",[t._v("n")]),t._v(" 个方法，则很容易知道这种判定的时间复杂度为 "),e("code",[t._v("O(mn)")]),t._v("，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 "),e("code",[t._v("O(m+n)")]),t._v("。")]),t._v(" "),e("p",[t._v("这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。")]),t._v(" "),e("p",[t._v("直接来看一个例子：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport "fmt"\n\ntype coder interface {\n\tcode()\n\trun()\n}\n\ntype runner interface {\n\trun()\n}\n\ntype Gopher struct {\n\tlanguage string\n}\n\nfunc (g Gopher) code() {\n\treturn\n}\n\nfunc (g Gopher) run() {\n\treturn\n}\n\nfunc main() {\n\tvar c coder = Gopher{}\n\n\tvar r runner\n\tr = c\n\tfmt.Println(c, r)\n}\n')])])]),e("p",[t._v("简单解释下上述代码：定义了两个 "),e("code",[t._v("interface")]),t._v(": "),e("code",[t._v("coder")]),t._v(" 和 "),e("code",[t._v("runner")]),t._v("。定义了一个实体类型 "),e("code",[t._v("Gopher")]),t._v("，类型 "),e("code",[t._v("Gopher")]),t._v(" 实现了两个方法，分别是 "),e("code",[t._v("run()")]),t._v(" 和 "),e("code",[t._v("code()")]),t._v("。main 函数里定义了一个接口变量 "),e("code",[t._v("c")]),t._v("，绑定了一个 "),e("code",[t._v("Gopher")]),t._v(" 对象，之后将 "),e("code",[t._v("c")]),t._v(" 赋值给另外一个接口变量 "),e("code",[t._v("r")]),t._v(" 。赋值成功的原因是 "),e("code",[t._v("c")]),t._v(" 中包含 "),e("code",[t._v("run()")]),t._v(" 方法。这样，两个接口变量完成了转换。")]),t._v(" "),e("p",[t._v("执行命令：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("go tool compile -S ./src/main.go\n")])])]),e("p",[t._v("得到 main 函数的汇编命令，可以看到： "),e("code",[t._v("r = c")]),t._v(" 这一行语句实际上是调用了 "),e("code",[t._v("runtime.convI2I(SB)")]),t._v("，也就是 "),e("code",[t._v("convI2I")]),t._v(" 函数，从函数名来看，就是将一个 "),e("code",[t._v("interface")]),t._v(" 转换成另外一个 "),e("code",[t._v("interface")]),t._v("，看下它的源代码：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func convI2I(inter *interfacetype, i iface) (r iface) {\n\ttab := i.tab\n\tif tab == nil {\n\t\treturn\n\t}\n\tif tab.inter == inter {\n\t\tr.tab = tab\n\t\tr.data = i.data\n\t\treturn\n\t}\n\tr.tab = getitab(inter, tab._type, false)\n\tr.data = i.data\n\treturn\n}\n")])])]),e("p",[t._v("代码比较简单，函数参数 "),e("code",[t._v("inter")]),t._v(" 表示接口类型，"),e("code",[t._v("i")]),t._v(" 表示绑定了实体类型的接口，"),e("code",[t._v("r")]),t._v(" 则表示接口转换了之后的新的 "),e("code",[t._v("iface")]),t._v("。通过前面的分析，我们又知道， "),e("code",[t._v("iface")]),t._v(" 是由 "),e("code",[t._v("tab")]),t._v(" 和 "),e("code",[t._v("data")]),t._v(" 两个字段组成。所以，实际上 "),e("code",[t._v("convI2I")]),t._v(" 函数真正要做的事，找到新 "),e("code",[t._v("interface")]),t._v(" 的 "),e("code",[t._v("tab")]),t._v(" 和 "),e("code",[t._v("data")]),t._v("，就大功告成了。")]),t._v(" "),e("p",[t._v("我们还知道，"),e("code",[t._v("tab")]),t._v(" 是由接口类型 "),e("code",[t._v("interfacetype")]),t._v(" 和 实体类型 "),e("code",[t._v("_type")]),t._v("。所以最关键的语句是 "),e("code",[t._v("r.tab = getitab(inter, tab._type, false)")]),t._v("。")]),t._v(" "),e("p",[t._v("因此，重点来看下 "),e("code",[t._v("getitab")]),t._v(" 函数的源码，只看关键的地方：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {\n\t// ……\n\n    // 根据 inter, typ 计算出 hash 值\n\th := itabhash(inter, typ)\n\n\t// look twice - once without lock, once with.\n\t// common case will be no lock contention.\n\tvar m *itab\n\tvar locked int\n\tfor locked = 0; locked < 2; locked++ {\n\t\tif locked != 0 {\n\t\t\tlock(&ifaceLock)\n        }\n        \n        // 遍历哈希表的一个 slot\n\t\tfor m = (*itab)(atomic.Loadp(unsafe.Pointer(&hash[h]))); m != nil; m = m.link {\n\n            // 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）\n\t\t\tif m.inter == inter && m._type == typ {\n                // ……\n                \n\t\t\t\tif locked != 0 {\n\t\t\t\t\tunlock(&ifaceLock)\n\t\t\t\t}\n\t\t\t\treturn m\n\t\t\t}\n\t\t}\n\t}\n\n    // 在 hash 表中没有找到 itab，那么新生成一个 itab\n\tm = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))\n\tm.inter = inter\n    m._type = typ\n    \n    // 添加到全局的 hash 表中\n\tadditab(m, true, canfail)\n\tunlock(&ifaceLock)\n\tif m.bad {\n\t\treturn nil\n\t}\n\treturn m\n}\n")])])]),e("p",[t._v("简单总结一下：getitab 函数会根据 "),e("code",[t._v("interfacetype")]),t._v(" 和 "),e("code",[t._v("_type")]),t._v(" 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 "),e("code",[t._v("interfacetype")]),t._v(" 和 "),e("code",[t._v("_type")]),t._v(" 新生成一个 "),e("code",[t._v("itab")]),t._v("，并插入到 itab 哈希表，这样下一次就可以直接拿到 "),e("code",[t._v("itab")]),t._v("。")]),t._v(" "),e("p",[t._v("这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 "),e("code",[t._v("itab")]),t._v(" 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 "),e("code",[t._v("itab")]),t._v(" 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 "),e("code",[t._v("itab")]),t._v("。")]),t._v(" "),e("p",[t._v("再来看一下 "),e("code",[t._v("additab")]),t._v(" 函数的代码：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中\nfunc additab(m *itab, locked, canfail bool) {\n\tinter := m.inter\n\ttyp := m._type\n\tx := typ.uncommon()\n\n\t// both inter and typ have method sorted by name,\n\t// and interface names are unique,\n\t// so can iterate over both in lock step;\n    // the loop is O(ni+nt) not O(ni*nt).\n    // \n    // inter 和 typ 的方法都按方法名称进行了排序\n    // 并且方法名都是唯一的。所以循环的次数是固定的\n    // 只用循环 O(ni+nt)，而非 O(ni*nt)\n\tni := len(inter.mhdr)\n\tnt := int(x.mcount)\n\txmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]\n\tj := 0\n\tfor k := 0; k < ni; k++ {\n\t\ti := &inter.mhdr[k]\n\t\titype := inter.typ.typeOff(i.ityp)\n\t\tname := inter.typ.nameOff(i.name)\n\t\tiname := name.name()\n\t\tipkg := name.pkgPath()\n\t\tif ipkg == "" {\n\t\t\tipkg = inter.pkgpath.name()\n\t\t}\n\t\tfor ; j < nt; j++ {\n\t\t\tt := &xmhdr[j]\n            tname := typ.nameOff(t.name)\n            // 检查方法名字是否一致\n\t\t\tif typ.typeOff(t.mtyp) == itype && tname.name() == iname {\n\t\t\t\tpkgPath := tname.pkgPath()\n\t\t\t\tif pkgPath == "" {\n\t\t\t\t\tpkgPath = typ.nameOff(x.pkgpath).name()\n\t\t\t\t}\n\t\t\t\tif tname.isExported() || pkgPath == ipkg {\n\t\t\t\t\tif m != nil {\n                        // 获取函数地址，并加入到itab.fun数组中\n\t\t\t\t\t\tifn := typ.textOff(t.ifn)\n\t\t\t\t\t\t*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn\n\t\t\t\t\t}\n\t\t\t\t\tgoto nextimethod\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        // ……\n        \n\t\tm.bad = true\n\t\tbreak\n\tnextimethod:\n\t}\n\tif !locked {\n\t\tthrow("invalid itab locking")\n    }\n\n    // 计算 hash 值\n    h := itabhash(inter, typ)\n    // 加到Hash Slot链表中\n\tm.link = hash[h]\n\tm.inhash = true\n\tatomicstorep(unsafe.Pointer(&hash[h]), unsafe.Pointer(m))\n}\n')])])]),e("p",[e("code",[t._v("additab")]),t._v(" 会检查 "),e("code",[t._v("itab")]),t._v(" 持有的 "),e("code",[t._v("interfacetype")]),t._v(" 和 "),e("code",[t._v("_type")]),t._v(" 是否符合，就是看 "),e("code",[t._v("_type")]),t._v(" 是否完全实现了 "),e("code",[t._v("interfacetype")]),t._v(" 的方法，也就是看两者的方法列表重叠的部分就是 "),e("code",[t._v("interfacetype")]),t._v(" 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 "),e("code",[t._v("ni * nt")]),t._v("，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 "),e("code",[t._v("ni + nt")]),t._v(" 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。")]),t._v(" "),e("p",[t._v("求 hash 值的函数比较简单：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func itabhash(inter *interfacetype, typ *_type) uint32 {\n\th := inter.typ.hash\n\th += 17 * typ.hash\n\treturn h % hashSize\n}\n")])])]),e("p",[e("code",[t._v("hashSize")]),t._v(" 的值是 1009。")]),t._v(" "),e("p",[t._v("更一般的，当把实体类型赋值给接口的时候，会调用 "),e("code",[t._v("conv")]),t._v(" 系列函数，例如空接口调用 "),e("code",[t._v("convT2E")]),t._v(" 系列、非空接口调用 "),e("code",[t._v("convT2I")]),t._v(" 系列。这些函数比较相似：")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。")]),t._v(" "),e("li",[t._v("具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。")]),t._v(" "),e("li",[t._v("而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。")])])]),t._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[t._v("【接口赋值、反射】http://wudaijun.com/2018/01/go-interface-implement/")]),t._v(" "),e("p",[t._v("【itab】http://legendtkl.com/2017/07/01/golang-interface-implement/")]),t._v(" "),e("p",[t._v("【和 C++ 的对比】https://www.jianshu.com/p/b38b1719636e")]),t._v(" "),e("p",[t._v("【itab 原理】https://ninokop.github.io/2017/10/29/Go-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3/")]),t._v(" "),e("p",[t._v("【getitab源码说明】https://www.twblogs.net/a/5c245d59bd9eee16b3db561d")])])}),[],!1,null,null,null);n.default=i.exports}}]);