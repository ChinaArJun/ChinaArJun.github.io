(window.webpackJsonp=window.webpackJsonp||[]).push([[369],{948:function(t,n,e){"use strict";e.r(n);var c=e(44),a=Object(c.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#源码分析"}},[t._v("#")]),t._v(" 源码分析")]),t._v(" "),e("p",[t._v("我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，再根据一个实际的例子来具体研究。")]),t._v(" "),e("p",[t._v('接收操作有两种写法，一种带 "ok"，反应 channel 是否关闭；一种不带  "ok"，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。')]),t._v(" "),e("p",[t._v("经过编译器的处理后，这两种写法最后对应源码里的这两个函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// entry points for <- c from compiled code\nfunc chanrecv1(c *hchan, elem unsafe.Pointer) {\n\tchanrecv(c, elem, true)\n}\n\nfunc chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {\n\t_, received = chanrecv(c, elem, true)\n\treturn\n}\n")])])]),e("p",[e("code",[t._v("chanrecv1")]),t._v(' 函数处理不带 "ok" 的情形，'),e("code",[t._v("chanrecv2")]),t._v(' 则通过返回 "received" 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 '),e("code",[t._v("elem")]),t._v(" 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。")]),t._v(" "),e("p",[t._v("无论如何，最终转向了 "),e("code",[t._v("chanrecv")]),t._v(" 函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 位于 src/runtime/chan.go\n\n// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。\n// 如果 ep 是 nil，说明忽略了接收值。\n// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)\n// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)\n// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)\n// 如果 ep 非空，则应该指向堆或者函数调用者的栈\n\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {\n\t// 省略 debug 内容 …………\n\n\t// 如果是一个 nil 的 channel\n\tif c == nil {\n\t\t// 如果不阻塞，直接返回 (false, false)\n\t\tif !block {\n\t\t\treturn\n\t\t}\n\t\t// 否则，接收一个 nil 的 channel，goroutine 挂起\n\t\tgopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)\n\t\t// 不会执行到这里\n\t\tthrow("unreachable")\n\t}\n\n\t// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回\n\t// 当我们观察到 channel 没准备好接收：\n\t// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待\n\t// 2. 缓冲型，但 buf 里没有元素\n\t// 之后，又观察到 closed == 0，即 channel 未关闭。\n\t// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，\n\t// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)\n\tif !block && (c.dataqsiz == 0 && c.sendq.first == nil ||\n\t\tc.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&\n\t\tatomic.Load(&c.closed) == 0 {\n\t\treturn\n\t}\n\n\tvar t0 int64\n\tif blockprofilerate > 0 {\n\t\tt0 = cputicks()\n\t}\n\n\t// 加锁\n\tlock(&c.lock)\n\n\t// channel 已关闭，并且循环数组 buf 里没有元素\n\t// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况\n\t// 也就是说即使是关闭状态，但在缓冲型的 channel，\n\t// buf 里有元素的情况下还能接收到元素\n\tif c.closed != 0 && c.qcount == 0 {\n\t\tif raceenabled {\n\t\t\traceacquire(unsafe.Pointer(c))\n\t\t}\n\t\t// 解锁\n\t\tunlock(&c.lock)\n\t\tif ep != nil {\n\t\t\t// 从一个已关闭的 channel 执行接收操作，且未忽略返回值\n\t\t\t// 那么接收的值将是一个该类型的零值\n\t\t\t// typedmemclr 根据类型清理相应地址的内存\n\t\t\ttypedmemclr(c.elemtype, ep)\n\t\t}\n\t\t// 从一个已关闭的 channel 接收，selected 会返回true\n\t\treturn true, false\n\t}\n\n\t// 等待发送队列里有 goroutine 存在，说明 buf 是满的\n\t// 这有可能是：\n\t// 1. 非缓冲型的 channel\n\t// 2. 缓冲型的 channel，但 buf 满了\n\t// 针对 1，直接进行内存拷贝（从 sender goroutine -> receiver goroutine）\n\t// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部\n\tif sg := c.sendq.dequeue(); sg != nil {\n\t\t// Found a waiting sender. If buffer is size 0, receive value\n\t\t// directly from sender. Otherwise, receive from head of queue\n\t\t// and add sender\'s value to the tail of the queue (both map to\n\t\t// the same buffer slot because the queue is full).\n\t\trecv(c, sg, ep, func() { unlock(&c.lock) }, 3)\n\t\treturn true, true\n\t}\n\n\t// 缓冲型，buf 里有元素，可以正常接收\n\tif c.qcount > 0 {\n\t\t// 直接从循环数组里找到要接收的元素\n\t\tqp := chanbuf(c, c.recvx)\n\n\t\t// …………\n\n\t\t// 代码里，没有忽略要接收的值，不是 "<- ch"，而是 "val <- ch"，ep 指向 val\n\t\tif ep != nil {\n\t\t\ttypedmemmove(c.elemtype, ep, qp)\n\t\t}\n\t\t// 清理掉循环数组里相应位置的值\n\t\ttypedmemclr(c.elemtype, qp)\n\t\t// 接收游标向前移动\n\t\tc.recvx++\n\t\t// 接收游标归零\n\t\tif c.recvx == c.dataqsiz {\n\t\t\tc.recvx = 0\n\t\t}\n\t\t// buf 数组里的元素个数减 1\n\t\tc.qcount--\n\t\t// 解锁\n\t\tunlock(&c.lock)\n\t\treturn true, true\n\t}\n\n\tif !block {\n\t\t// 非阻塞接收，解锁。selected 返回 false，因为没有接收到值\n\t\tunlock(&c.lock)\n\t\treturn false, false\n\t}\n\n\t// 接下来就是要被阻塞的情况了\n\t// 构造一个 sudog\n\tgp := getg()\n\tmysg := acquireSudog()\n\tmysg.releasetime = 0\n\tif t0 != 0 {\n\t\tmysg.releasetime = -1\n\t}\n\n\t// 待接收数据的地址保存下来\n\tmysg.elem = ep\n\tmysg.waitlink = nil\n\tgp.waiting = mysg\n\tmysg.g = gp\n\tmysg.selectdone = nil\n\tmysg.c = c\n\tgp.param = nil\n\t// 进入channel 的等待接收队列\n\tc.recvq.enqueue(mysg)\n\t// 将当前 goroutine 挂起\n\tgoparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)\n\n\t// 被唤醒了，接着从这里继续执行一些扫尾工作\n\tif mysg != gp.waiting {\n\t\tthrow("G waiting list is corrupted")\n\t}\n\tgp.waiting = nil\n\tif mysg.releasetime > 0 {\n\t\tblockevent(mysg.releasetime-t0, 2)\n\t}\n\tclosed := gp.param == nil\n\tgp.param = nil\n\tmysg.c = nil\n\treleaseSudog(mysg)\n\treturn true, !closed\n}\n')])])]),e("p",[t._v("上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。")])]),t._v(" "),e("li",[e("p",[t._v("和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。")])])]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\t// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)\n\tif !block && (c.dataqsiz == 0 && c.sendq.first == nil ||\n\t\tc.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&\n\t\tatomic.Load(&c.closed) == 0 {\n\t\treturn\n\t}\n")])])]),e("p",[t._v("当我们观察到 channel 没准备好接收：")]),t._v(" "),e("ol",[e("li",[t._v("非缓冲型，等待发送列队里没有 goroutine 在等待")]),t._v(" "),e("li",[t._v("缓冲型，但 buf 里没有元素")])]),t._v(" "),e("p",[t._v("之后，又观察到 closed == 0，即 channel 未关闭。")]),t._v(" "),e("p",[t._v("因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。")])]),t._v(" "),e("li",[e("p",[t._v("接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。")])])]),t._v(" "),e("p",[t._v("于是，调用 recv 函数：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {\n\t// 如果是非缓冲型的 channel\n\tif c.dataqsiz == 0 {\n\t\tif raceenabled {\n\t\t\tracesync(c, sg)\n\t\t}\n\t\t// 未忽略接收的数据\n\t\tif ep != nil {\n\t\t\t// 直接拷贝数据，从 sender goroutine -> receiver goroutine\n\t\t\trecvDirect(c.elemtype, sg, ep)\n\t\t}\n\t} else {\n\t\t// 缓冲型的 channel，但 buf 已满。\n\t\t// 将循环数组 buf 队首的元素拷贝到接收数据的地址\n\t\t// 将发送者的数据入队。实际上这时 revx 和 sendx 值相等\n\t\t// 找到接收游标\n\t\tqp := chanbuf(c, c.recvx)\n\t\t// …………\n\t\t// 将接收游标处的数据拷贝给接收者\n\t\tif ep != nil {\n\t\t\ttypedmemmove(c.elemtype, ep, qp)\n\t\t}\n\n\t\t// 将发送者数据拷贝到 buf\n\t\ttypedmemmove(c.elemtype, qp, sg.elem)\n\t\t// 更新游标值\n\t\tc.recvx++\n\t\tif c.recvx == c.dataqsiz {\n\t\t\tc.recvx = 0\n\t\t}\n\t\tc.sendx = c.recvx\n\t}\n\tsg.elem = nil\n\tgp := sg.g\n\n\t// 解锁\n\tunlockf()\n\tgp.param = unsafe.Pointer(sg)\n\tif sg.releasetime != 0 {\n\t\tsg.releasetime = cputicks()\n\t}\n\n\t// 唤醒发送的 goroutine。需要等到调度器的光临\n\tgoready(gp, skip+1)\n}\n")])])]),e("p",[t._v("如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {\n\t// dst is on our stack or the heap, src is on another stack.\n\tsrc := sg.elem\n\ttypeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)\n\tmemmove(dst, src, t.size)\n}\n")])])]),e("p",[t._v("否则，就是缓冲型 channel，而 buf 又满了的情形。说明发送游标和接收游标重合了，因此需要先找到接收游标：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// chanbuf(c, i) is pointer to the i'th slot in the buffer.\nfunc chanbuf(c *hchan, i uint) unsafe.Pointer {\n\treturn add(c.buf, uintptr(i)*uintptr(c.elemsize))\n}\n")])])]),e("p",[t._v("将该处的元素拷贝到接收地址。然后将发送者待发送的数据拷贝到接收游标处。这样就完成了接收数据和发送数据的操作。接着，分别将发送游标和接收游标向前进一，如果发生“环绕”，再从 0 开始。")]),t._v(" "),e("p",[t._v("最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("然后，如果 channel 的 buf 里还有数据，说明可以比较正常地接收。注意，这里，即使是在 channel 已经关闭的情况下，也是可以走到这里的。这一步比较简单，正常地将 buf 里接收游标处的数据拷贝到接收数据的地址。")])]),t._v(" "),e("li",[e("p",[t._v("到了最后一步，走到这里来的情形是要阻塞的。当然，如果 block 传进来的值是 false，那就不阻塞，直接返回就好了。")])])]),t._v(" "),e("p",[t._v("先构造一个 sudog，接着就是保存各种值了。注意，这里会将接收数据的地址存储到了 "),e("code",[t._v("elem")]),t._v(" 字段，当被唤醒时，接收到的数据就会保存到这个字段指向的地址。然后将 sudog 添加到 channel 的 recvq 队列里。调用 goparkunlock 函数将 goroutine 挂起。")]),t._v(" "),e("p",[t._v("接下来的代码就是 goroutine 被唤醒后的各种收尾工作了。")]),t._v(" "),e("h1",{attrs:{id:"案例分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例分析"}},[t._v("#")]),t._v(" 案例分析")]),t._v(" "),e("p",[t._v("从 channel 接收和向 channel 发送数据的过程我们均会使用下面这个例子来进行说明：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('func goroutineA(a <-chan int) {\n\tval := <- a\n\tfmt.Println("G1 received data: ", val)\n\treturn\n}\n\nfunc goroutineB(b <-chan int) {\n\tval := <- b\n\tfmt.Println("G2 received data: ", val)\n\treturn\n}\n\nfunc main() {\n\tch := make(chan int)\n\tgo goroutineA(ch)\n\tgo goroutineB(ch)\n\tch <- 3\n\ttime.Sleep(time.Second)\n}\n')])])]),e("p",[t._v("首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。")]),t._v(" "),e("p",[t._v("程序第 14 行创建了一个非缓冲型的 channel，我们只看 chan 结构体中的一些重要字段，来从整体层面看一下 chan 的状态，一开始什么都没有：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61338760-91a63000-a86d-11e9-9c7e-edee8a594f66.png",alt:"unbuffered chan"}})]),t._v(" "),e("p",[t._v("接着，第 15、16 行分别创建了一个 goroutine，各自执行了一个接收操作。通过前面的源码分析，我们知道，这两个 goroutine （后面称为 G1 和 G2 好了）都会被阻塞在接收操作。G1 和 G2 会挂在 channel 的 recq 队列中，形成一个双向循环链表。")]),t._v(" "),e("p",[t._v("在程序的 17 行之前，chan 的整体数据结构如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61179141-19eac200-a62f-11e9-836d-b6b95d52f6fb.png",alt:"chan struct at the runtime"}})]),t._v(" "),e("p",[e("code",[t._v("buf")]),t._v(" 指向一个长度为 0 的数组，qcount 为 0，表示 channel 中没有元素。重点关注 "),e("code",[t._v("recvq")]),t._v(" 和 "),e("code",[t._v("sendq")]),t._v("，它们是 waitq 结构体，而 waitq 实际上就是一个双向链表，链表的元素是 sudog，里面包含 "),e("code",[t._v("g")]),t._v(" 字段，"),e("code",[t._v("g")]),t._v(" 表示一个 goroutine，所以 sudog 可以看成一个 goroutine。recvq 存储那些尝试读取 channel 但被阻塞的 goroutine，sendq 则存储那些尝试写入 channel，但被阻塞的 goroutine。")]),t._v(" "),e("p",[t._v("此时，我们可以看到，recvq 里挂了两个 goroutine，也就是前面启动的 G1 和 G2。因为没有 goroutine 接收，而 channel 又是无缓冲类型，所以 G1 和 G2 被阻塞。sendq 没有被阻塞的 goroutine。")]),t._v(" "),e("p",[e("code",[t._v("recvq")]),t._v(" 的数据结构如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61179210-d3966280-a630-11e9-8c73-5a22340910a6.png",alt:"recvq structure"}})]),t._v(" "),e("p",[t._v("再从整体上来看一下 chan 此时的状态：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61340165-bbfaec00-a873-11e9-83de-66bc63e603f1.png",alt:"chan state"}})]),t._v(" "),e("p",[t._v("G1 和 G2 被挂起了，状态是 "),e("code",[t._v("WAITING")]),t._v("。关于 goroutine 调度器这块不是今天的重点，当然后面肯定会写相关的文章。这里先简单说下，goroutine 是用户态的协程，由 Go runtime 进行管理，作为对比，内核线程由 OS 进行管理。Goroutine 更轻量，因此我们可以轻松创建数万 goroutine。")]),t._v(" "),e("p",[t._v("一个内核线程可以管理多个 goroutine，当其中一个 goroutine 阻塞时，内核线程可以调度其他的 goroutine 来运行，内核线程本身不会阻塞。这就是通常我们说的 "),e("code",[t._v("M:N")]),t._v(" 模型：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61340362-8c001880-a874-11e9-9237-d97e6105cd62.png",alt:"M:N scheduling"}})]),t._v(" "),e("p",[e("code",[t._v("M:N")]),t._v(" 模型通常由三部分构成：M、P、G。M 是内核线程，负责运行 goroutine；P 是 context，保存 goroutine 运行所需要的上下文，它还维护了可运行（runnable）的 goroutine 列表；G 则是待运行的 goroutine。M 和 P 是 G 运行的基础。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61340473-1183c880-a875-11e9-9b3e-86f376d3ae55.png",alt:"MGP"}})]),t._v(" "),e("p",[t._v("继续回到例子。假设我们只有一个 M，当 G1（"),e("code",[t._v("go goroutineA(ch)")]),t._v("） 运行到 "),e("code",[t._v("val := <- a")]),t._v(" 时，它由本来的 running 状态变成了 waiting 状态（调用了 gopark 之后的结果）：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61340756-45abb900-a876-11e9-8ac7-4c40b4c23253.png",alt:"G1 running"}})]),t._v(" "),e("p",[t._v("G1 脱离与 M 的关系，但调度器可不会让 M 闲着，所以会接着调度另一个 goroutine 来运行：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/61340787-67a53b80-a876-11e9-94a4-a6c3698eb8ed.png",alt:"G1 waiting"}})]),t._v(" "),e("p",[t._v("G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。")]),t._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[t._v("【深入 channel 底层】https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8")]),t._v(" "),e("p",[t._v("【Kavya在Gopher Con 上关于 channel 的设计，非常好】https://speakerd.s3.amazonaws.com/presentations/10ac0b1d76a6463aa98ad6a9dec917a7/GopherCon_v10.0.pdf")])])}),[],!1,null,null,null);n.default=a.exports}}]);