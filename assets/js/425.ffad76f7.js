(window.webpackJsonp=window.webpackJsonp||[]).push([[425],{1003:function(t,a,e){"use strict";e.r(a);var n=e(44),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。")]),t._v(" "),e("p",[t._v("然而，Go 语言的指针相比 C 的指针有很多限制。这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？更别说像 C/C++ 还需要程序员自己清理“垃圾”。所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。")]),t._v(" "),e("p",[t._v("相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。")]),t._v(" "),e("p",[t._v("限制一："),e("code",[t._v("Go 的指针不能进行数学运算")]),t._v("。")]),t._v(" "),e("p",[t._v("来看一个简单的例子：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("a := 5\np := &a\n\np++\np = &a + 3\n")])])]),e("p",[t._v("上面的代码将不能通过编译，会报编译错误："),e("code",[t._v("invalid operation")]),t._v("，也就是说不能对指针做数学运算。")]),t._v(" "),e("p",[t._v("限制二："),e("code",[t._v("不同类型的指针不能相互转换")]),t._v("。")]),t._v(" "),e("p",[t._v("例如下面这个简短的例子：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("func main() {\n\ta := int(100)\n\tvar f *float64\n\t\n\tf = &a\n}\n")])])]),e("p",[t._v("也会报编译错误：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("cannot use "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("a "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type *int"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" as "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("type")]),t._v(" *float64 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" assignment\n")])])]),e("p",[t._v("限制三："),e("code",[t._v("不同类型的指针不能使用 == 或 != 比较")]),t._v("。")]),t._v(" "),e("p",[t._v("只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 "),e("code",[t._v("==")]),t._v(" 和 "),e("code",[t._v("!=")]),t._v(" 直接和 "),e("code",[t._v("nil")]),t._v(" 作比较。")]),t._v(" "),e("p",[t._v("限制四："),e("code",[t._v("不同类型的指针变量不能相互赋值")]),t._v("。")]),t._v(" "),e("p",[t._v("这一点同限制三。")]),t._v(" "),e("p",[t._v("unsafe.Pointer 在 unsafe 包：")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type ArbitraryType int\n\ntype Pointer *ArbitraryType\n")])])]),e("p",[t._v("从命名来看，"),e("code",[t._v("Arbitrary")]),t._v(" 是任意的意思，也就是说 Pointer 可以指向任意类型，实际上它类似于 C 语言里的 "),e("code",[t._v("void*")]),t._v("。")]),t._v(" "),e("p",[t._v("unsafe 包提供了 2 点重要的能力：")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("任何类型的指针和 unsafe.Pointer 可以相互转换。")]),t._v(" "),e("li",[t._v("uintptr 类型和 unsafe.Pointer 可以相互转换。")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-images.githubusercontent.com/7698088/58747453-1dbaee80-849e-11e9-8c75-2459f76792d2.png",alt:"type pointer uintptr"}})]),t._v(" "),e("p",[t._v("pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// uintptr 是一个整数类型，它足够大，可以存储\ntype uintptr uintptr\n")])])]),e("p",[t._v("还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收。而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。")]),t._v(" "),e("p",[t._v("unsafe 包中的几个函数都是在编译期间执行完毕，毕竟，编译器对内存分配这些操作“了然于胸”。在 "),e("code",[t._v("/usr/local/go/src/cmd/compile/internal/gc/unsafe.go")]),t._v(" 路径下，可以看到编译期间 Go 对 unsafe 包中函数的处理。")])])}),[],!1,null,null,null);a.default=s.exports}}]);