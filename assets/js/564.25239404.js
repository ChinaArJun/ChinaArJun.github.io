(window.webpackJsonp=window.webpackJsonp||[]).push([[564],{1161:function(t,n,a){"use strict";a.r(n);var e=a(44),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("我们知道，Go 语言中不允许隐式类型转换，也就是说 "),a("code",[t._v("=")]),t._v(" 两边，不允许出现类型不相同的变量。")]),t._v(" "),a("p",[a("code",[t._v("类型转换")]),t._v("、"),a("code",[t._v("类型断言")]),t._v("本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。")]),t._v(" "),a("h1",{attrs:{id:"类型转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[t._v("#")]),t._v(" 类型转换")]),t._v(" "),a("p",[t._v("对于"),a("code",[t._v("类型转换")]),t._v("而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：")]),t._v(" "),a("blockquote",[a("p",[t._v("<结果类型> := <目标类型> ( <表达式> )")])]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package main\n\nimport "fmt"\n\nfunc main() {\n\tvar i int = 9\n\n\tvar f float64\n\tf = float64(i)\n\tfmt.Printf("%T, %v\\n", f, f)\n\n\tf = 10.8\n\ta := int(f)\n\tfmt.Printf("%T, %v\\n", a, a)\n\n\t// s := []int(i)\n}\n')])])]),a("p",[t._v("上面的代码里，我定义了一个 "),a("code",[t._v("int")]),t._v(" 型和 "),a("code",[t._v("float64")]),t._v(" 型的变量，尝试在它们之前相互转换，结果是成功的："),a("code",[t._v("int")]),t._v(" 型和 "),a("code",[t._v("float64")]),t._v(" 是相互兼容的。")]),t._v(" "),a("p",[t._v("如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("cannot convert i "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" to "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("int\n")])])]),a("h1",{attrs:{id:"断言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#断言"}},[t._v("#")]),t._v(" 断言")]),t._v(" "),a("p",[t._v("前面说过，因为空接口 "),a("code",[t._v("interface{}")]),t._v(" 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 "),a("code",[t._v("interface{}")]),t._v("，那么在函数中，需要对形参进行断言，从而得到它的真实类型。")]),t._v(" "),a("p",[t._v("断言的语法为：")]),t._v(" "),a("blockquote",[a("p",[t._v("<目标类型的值>，<布尔参数> := <表达式>.( 目标类型 ) // 安全类型断言\n<目标类型的值> := <表达式>.( 目标类型 )　　//非安全类型断言")])]),t._v(" "),a("p",[t._v("类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。")]),t._v(" "),a("p",[t._v("还是来看一个简短的例子：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package main\n\nimport "fmt"\n\ntype Student struct {\n\tName string\n\tAge int\n}\n\nfunc main() {\n\tvar i interface{} = new(Student)\n\ts := i.(Student)\n\t\n\tfmt.Println(s)\n}\n')])])]),a("p",[t._v("运行一下：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("panic: interface conversion: interface "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" is *main.Student, not main.Student\n")])])]),a("p",[t._v("直接 "),a("code",[t._v("panic")]),t._v(" 了，这是因为 "),a("code",[t._v("i")]),t._v(" 是 "),a("code",[t._v("*Student")]),t._v(" 类型，并非 "),a("code",[t._v("Student")]),t._v(" 类型，断言失败。这里直接发生了 "),a("code",[t._v("panic")]),t._v("，线上代码可能并不适合这样做，可以采用“安全断言”的语法：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func main() {\n\tvar i interface{} = new(Student)\n\ts, ok := i.(Student)\n\tif ok {\n\t\tfmt.Println(s)\n\t}\n}\n")])])]),a("p",[t._v("这样，即使断言失败也不会 "),a("code",[t._v("panic")]),t._v("。")]),t._v(" "),a("p",[t._v("断言其实还有另一种形式，就是用在利用 "),a("code",[t._v("switch")]),t._v(" 语句判断接口的类型。每一个 "),a("code",[t._v("case")]),t._v(" 会被顺序地考虑。当命中一个 "),a("code",[t._v("case")]),t._v(" 时，就会执行 "),a("code",[t._v("case")]),t._v(" 中的语句，因此 "),a("code",[t._v("case")]),t._v(" 语句的顺序是很重要的，因为很有可能会有多个 "),a("code",[t._v("case")]),t._v(" 匹配的情况。")]),t._v(" "),a("p",[t._v("代码示例如下：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func main() {\n\t//var i interface{} = new(Student)\n\t//var i interface{} = (*Student)(nil)\n\tvar i interface{}\n\n\tfmt.Printf("%p %v\\n", &i, i)\n\n\tjudge(i)\n}\n\nfunc judge(v interface{}) {\n\tfmt.Printf("%p %v\\n", &v, v)\n\n\tswitch v := v.(type) {\n\tcase nil:\n\t\tfmt.Printf("%p %v\\n", &v, v)\n\t\tfmt.Printf("nil type[%T] %v\\n", v, v)\n\n\tcase Student:\n\t\tfmt.Printf("%p %v\\n", &v, v)\n\t\tfmt.Printf("Student type[%T] %v\\n", v, v)\n\n\tcase *Student:\n\t\tfmt.Printf("%p %v\\n", &v, v)\n\t\tfmt.Printf("*Student type[%T] %v\\n", v, v)\n\n\tdefault:\n\t\tfmt.Printf("%p %v\\n", &v, v)\n\t\tfmt.Printf("unknow\\n")\n\t}\n}\n\ntype Student struct {\n\tName string\n\tAge int\n}\n\n')])])]),a("p",[a("code",[t._v("main")]),t._v(" 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("// --- var i interface"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n0xc4200701b0 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Age: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n0xc4200701d0 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Age: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n0xc420080020 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Age: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n*Student type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("*main.Student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Age: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n// --- var i interface"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("*Student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n0xc42000e1d0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n0xc42000e1f0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n0xc42000c030 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n*Student type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("*main.Student"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n// --- var i interface"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n0xc42000e1d0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n0xc42000e1e0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n0xc42000e1f0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nnil type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("nil"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("对于第一行语句：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var i interface{} = new(Student)\n")])])]),a("p",[a("code",[t._v("i")]),t._v(" 是一个 "),a("code",[t._v("*Student")]),t._v(" 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 "),a("code",[t._v("main")]),t._v(" 函数里有一个局部变量 "),a("code",[t._v("i")]),t._v("；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 "),a("code",[t._v("v")]),t._v("，它是 "),a("code",[t._v("i")]),t._v(" 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。")]),t._v(" "),a("p",[t._v("对于第二行语句：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var i interface{} = (*Student)(nil)\n")])])]),a("p",[t._v("这里想说明的其实是 "),a("code",[t._v("i")]),t._v(" 在这里动态类型是 "),a("code",[t._v("(*Student)")]),t._v(", 数据为 "),a("code",[t._v("nil")]),t._v("，它的类型并不是 "),a("code",[t._v("nil")]),t._v("，它与 "),a("code",[t._v("nil")]),t._v(" 作比较的时候，得到的结果也是 "),a("code",[t._v("false")]),t._v("。")]),t._v(" "),a("p",[t._v("最后一行语句：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var i interface{}\n")])])]),a("p",[t._v("这回 "),a("code",[t._v("i")]),t._v(" 才是 "),a("code",[t._v("nil")]),t._v(" 类型。")]),t._v(" "),a("p",[t._v("【引申1】\n"),a("code",[t._v("fmt.Println")]),t._v(" 函数的参数是 "),a("code",[t._v("interface")]),t._v("。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 "),a("code",[t._v("String()")]),t._v(" 方法，如果实现了，则直接打印输出 "),a("code",[t._v("String()")]),t._v(" 方法的结果；否则，会通过反射来遍历对象的成员进行打印。")]),t._v(" "),a("p",[t._v("再来看一个简短的例子，比较简单，不要紧张：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package main\n\nimport "fmt"\n\ntype Student struct {\n\tName string\n\tAge int\n}\n\nfunc main() {\n\tvar s = Student{\n\t\tName: "qcrao",\n\t\tAge: 18,\n\t}\n\n\tfmt.Println(s)\n}\n')])])]),a("p",[t._v("因为 "),a("code",[t._v("Student")]),t._v(" 结构体没有实现 "),a("code",[t._v("String()")]),t._v(" 方法，所以 "),a("code",[t._v("fmt.Println")]),t._v(" 会利用反射挨个打印成员变量：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("qcrao "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("增加一个 "),a("code",[t._v("String()")]),t._v(" 方法的实现：")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func (s Student) String() string {\n\treturn fmt.Sprintf("[Name: %s], [Age: %d]", s.Name, s.Age)\n}\n')])])]),a("p",[t._v("打印结果：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Name: qcrao"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Age: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),a("p",[t._v("按照我们自定义的方法来打印了。")]),t._v(" "),a("p",[t._v("【引申2】\n针对上面的例子，如果改一下：")]),t._v(" "),a("div",{staticClass:"language-goalng extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('func (s *Student) String() string {\n\treturn fmt.Sprintf("[Name: %s], [Age: %d]", s.Name, s.Age)\n}\n')])])]),a("p",[t._v("注意看两个函数的接受者类型不同，现在 "),a("code",[t._v("Student")]),t._v(" 结构体只有一个接受者类型为 "),a("code",[t._v("指针类型")]),t._v(" 的 "),a("code",[t._v("String()")]),t._v(" 函数，打印结果：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("qcrao "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("为什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("类型 "),a("code",[t._v("T")]),t._v(" 只有接受者是 "),a("code",[t._v("T")]),t._v(" 的方法；而类型 "),a("code",[t._v("*T")]),t._v(" 拥有接受者是 "),a("code",[t._v("T")]),t._v(" 和 "),a("code",[t._v("*T")]),t._v(" 的方法。语法上 "),a("code",[t._v("T")]),t._v(" 能直接调 "),a("code",[t._v("*T")]),t._v(" 的方法仅仅是 "),a("code",[t._v("Go")]),t._v(" 的语法糖。")])]),t._v(" "),a("p",[t._v("所以， "),a("code",[t._v("Student")]),t._v(" 结构体定义了接受者类型是值类型的 "),a("code",[t._v("String()")]),t._v(" 方法时，通过")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fmt.Println(s)\nfmt.Println(&s)\n")])])]),a("p",[t._v("均可以按照自定义的格式来打印。")]),t._v(" "),a("p",[t._v("如果 "),a("code",[t._v("Student")]),t._v(" 结构体定义了接受者类型是指针类型的 "),a("code",[t._v("String()")]),t._v(" 方法时，只有通过")]),t._v(" "),a("div",{staticClass:"language-golang extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("fmt.Println(&s)\n")])])]),a("p",[t._v("才能按照自定义的格式打印。")]),t._v(" "),a("h1",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("p",[t._v("【类型转换和断言】https://www.cnblogs.com/zrtqsk/p/4157350.html")]),t._v(" "),a("p",[t._v("【断言】https://studygolang.com/articles/11419")])])}),[],!1,null,null,null);n.default=s.exports}}]);