(window.webpackJsonp=window.webpackJsonp||[]).push([[411],{990:function(t,a,e){"use strict";e.r(a);var n=e(44),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Go 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 key 类型的零值。如果 key 是 int 型就会返回 0，如果 key 是 string 类型，就会返回空字符串。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport "fmt"\n\nfunc main() {\n\tageMap := make(map[string]int)\n\tageMap["qcrao"] = 18\n\n    // 不带 comma 用法\n\tage1 := ageMap["stefno"]\n\tfmt.Println(age1)\n\n    // 带 comma 用法\n\tage2, ok := ageMap["stefno"]\n\tfmt.Println(age2, ok)\n}\n')])])]),e("p",[t._v("运行结果：")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n")])])]),e("p",[t._v("以前一直觉得好神奇，怎么实现的？这其实是编译器在背后做的工作：分析代码后，将两种语法对应到底层两个不同的函数。")]),t._v(" "),e("div",{staticClass:"language-golang extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// src/runtime/hashmap.go\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\nfunc mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n")])])]),e("p",[t._v("源码里，函数命名不拘小节，直接带上后缀 1，2，完全不理会《代码大全》里的那一套命名的做法。从上面两个函数的声明也可以看出差别了，"),e("code",[t._v("mapaccess2")]),t._v(" 函数返回值多了一个 bool 型变量，两者的代码也是完全一样的，只是在返回值后面多加了一个 false 或者 true。")]),t._v(" "),e("p",[t._v("另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("key 类型")]),t._v(" "),e("th",[t._v("查找")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("uint32")]),t._v(" "),e("td",[t._v("mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer")])]),t._v(" "),e("tr",[e("td",[t._v("uint32")]),t._v(" "),e("td",[t._v("mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)")])]),t._v(" "),e("tr",[e("td",[t._v("uint64")]),t._v(" "),e("td",[t._v("mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer")])]),t._v(" "),e("tr",[e("td",[t._v("uint64")]),t._v(" "),e("td",[t._v("mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)")])]),t._v(" "),e("tr",[e("td",[t._v("string")]),t._v(" "),e("td",[t._v("mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer")])]),t._v(" "),e("tr",[e("td",[t._v("string")]),t._v(" "),e("td",[t._v("mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)")])])])]),t._v(" "),e("p",[t._v("这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。")]),t._v(" "),e("p",[t._v("上面这些函数都是在文件 "),e("code",[t._v("src/runtime/hashmap_fast.go")]),t._v(" 里。")])])}),[],!1,null,null,null);a.default=s.exports}}]);