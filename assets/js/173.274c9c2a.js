(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{727:function(e,n,a){"use strict";a.r(n);var t=a(44),c=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"链码基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链码基本操作"}},[e._v("#")]),e._v(" 链码基本操作")]),e._v(" "),a("h2",{attrs:{id:"链码操作流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链码操作流程"}},[e._v("#")]),e._v(" 链码操作流程")]),e._v(" "),a("p",[e._v("用户可以通过命令行方式来管理链码。自 2.0 开始正式使用新的 peer lifecycle chaincode 命令来维护链码的生命周期，所支持的链码子命令包括 package（打包）、install（安装）、queryinstalled（查询已安装）、approveformyorg（批准提交）、commit（提交）、querycommitted（查询已提交）。原有的 peer chaincode 系列命令仍然支持。")]),e._v(" "),a("p",[e._v("各个命令的功能总结如下表所示：")]),e._v(" "),a("p",[e._v("命令\t发往组件\t功能\npackage\t本地操作\t打包本地链码为部署 Spec 包\ninstall\tPeer 节点\t将链码信息打包并安装到 Peer\nlist\tPeer 节点\t列出链码信息，包括某个 Peer 上安装过的链码或通道内实例化过的链码\ninstantiate\tPeer 节点和排序服务\t在通道中实例化链码\ninvoke\tPeer 节点和排序服务\t调用链码\nupgrade\tPeer 节点和排序服务\t升级链码\nquery\tPeer 节点\t查询链码\n可以通过 peer chaincode "),a("subcommand",[e._v(" --help 来查看具体的命令使用说明。")])],1),e._v(" "),a("p",[e._v("这些操作管理了链码的整个生命周期，如下图所示。\n"),a("img",{attrs:{src:"http://qiniu.zhequtao.com/picgo/20210201103024.png",alt:"20210201103024"}})]),e._v(" "),a("p",[e._v("首先，用户需要将链码安装到 Peer 节点，之后可以在 Peer 所属的某个通道内实例化链码容器。此时链码处于运行状态，应用可以通过 invoke 或 query 来调用链码。链码在一定时间（环境变量 CRC_MAX_IDLE_TIME 指定）内不被调用会处于空闲状态，自动被停止删除；如果被调用则重新实例化。此外，用户还可以升级链码到新的版本。")]),e._v(" "),a("p",[e._v("后面将以 Fabric 项目中自带的 Go 语言 example02 链码（路径在 examples/chaincode/go/chaincode_example02）为例进行相关命令讲解。")]),e._v(" "),a("ul",[a("li",[e._v("说明：这些命令的实现位于 github.com/hyperledger/fabric/internal/peer/lifecycle。")])]),e._v(" "),a("h2",{attrs:{id:"_1、上传安装链码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、上传安装链码"}},[e._v("#")]),e._v(" 1、上传安装链码")]),e._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#安装链码 -n name -v version")]),e._v("\npeer chaincode "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -p chaincode/abstore/go -n mycc -v "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\npeer chaincode "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -p chaincode/bill -n bill -v "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n\npeer chaincode "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -p chaincode/bill -n bill -v "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n\n进入cli容器中\n\ndocker "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("exec")]),e._v(" -it cli "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("bash")]),e._v("\n\n安装链码\n\npeer chaincode "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -p chaincode/abstore -n mycc -v "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n")])])]),a("h2",{attrs:{id:"_2、实例化初始化链码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、实例化初始化链码"}},[e._v("#")]),e._v(" 2、实例化初始化链码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('执行 instantiate 命令的用户身份必须满足实例化的策略（默认为通道内 MSP 管理员角色），并且在所指定的通道上拥有写（Write）权限。在 instantiate 命令中可以通过 -P 参数指定链码调用的背书策略（Endorsement Policy），在 Commit 阶段会进行策略检查。\npeer chaincode instantiate -n bill -v 0 -c \'{"Args":["init","tom","100","bob","200"]}\' -C mychannel\npeer chaincode instantiate -n mycc -v 0 -c \'{"Args":["init","tom","100","bob","200"]}\' -C mychannel\n\npeer chaincode instantiate -o orderer.finebaas.com:7050  -C mychannel -n faceccd -v 1.0 -c \'{"Args":["init"]}\' -P "OR (\'Org1MSP.peer\',\'Org2MSP.peer\')"\n\n$ APP_CHANNEL="businesschannel" # 设置默认的通道名称\n$ peer chaincode instantiate \\\n    -o orderer0:7050 \\\n    -C ${APP_CHANNEL} \\\n    -n test_cc \\\n    -v 1.0 \\\n    -c \'{"Args":["init","a","100","b","200"]}\' \\\n    -P "OR (\'Org1MSP.member\',\'Org2MSP.member\')" \\\n    --collections-config collection.json \\\n    --tls \\\n    --cafile ${ORDERER_TLS_CA}\n')])])]),a("h2",{attrs:{id:"_12-开始执行我们chaincode的中的函数进行链码的基本操作（终端3）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-开始执行我们chaincode的中的函数进行链码的基本操作（终端3）"}},[e._v("#")]),e._v(" 12.开始执行我们chaincode的中的函数进行链码的基本操作（终端3）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('新建账户实体\n\npeer chaincode invoke -n mycc -c \'{"Args":["create","lily","150"]}\' -C mychannel\n\n查询\n\npeer chaincode query -n mycc -c \'{"Args":["query","lily"]}\' -C mychannel\npeer chaincode query -n mycc -c \'{"Args":["query","tom"]}\' -C mychannel\npeer chaincode query -n mycc -c \'{"Args":["query","bob"]}\' -C mychannel\n\n转账\n\nbob给lily转账10\n\npeer chaincode invoke -n mycc -c \'{"Args":["transfer","bob","lily","10"]}\' -C myc\n\n转账后再查询\n\npeer chaincode query -n mycc -c \'{"Args":["query","lily"]}\' -C myc\npeer chaincode query -n mycc -c \'{"Args":["query","bob"]}\' -C myc\n\n删除tom账户实体\n\npeer chaincode invoke -n mycc -c \'{"Args":["delete","tom"]}\' -C myc\n')])])]),a("p",[e._v("至此我们对于chaincode的开发者模式的基本学习已经完毕，希望对大家有所收获")])])}),[],!1,null,null,null);n.default=c.exports}}]);