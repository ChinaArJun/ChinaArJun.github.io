(window.webpackJsonp=window.webpackJsonp||[]).push([[285],{863:function(a,e,t){"use strict";t.r(e);var n=t(44),v=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_1-1-聊一聊，go-的相对路径问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-聊一聊，go-的相对路径问题"}},[a._v("#")]),a._v(" 1.1 聊一聊，Go 的相对路径问题")]),a._v(" "),t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),t("p",[t("code",[a._v("Golang")]),a._v(" 中存在各种运行方式，如何"),t("strong",[a._v("正确的引用文件路径")]),a._v("成为一个值得商议的问题")]),a._v(" "),t("p",[a._v("以 "),t("a",{attrs:{href:"https://github.com/EDDYCJY/go-gin-example",target:"_blank",rel:"noopener noreferrer"}},[a._v("gin-blog"),t("OutboundLink")],1),a._v(" 为例，当我们在项目根目录下，执行 "),t("code",[a._v("go run main.go")]),a._v(" 时能够正常运行（"),t("code",[a._v("go build")]),a._v("也是正常的）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('[$ gin-blog]# go run main.go\n[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.\n - using env:    export GIN_MODE=release\n - using code:    gin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    /api/v1/tags              --\x3e gin-blog/routers/api/v1.GetTags (3 handlers)\n...\n')])])]),t("p",[a._v("那么在不同的目录层级下，不同的方式运行，又是怎么样的呢，带着我们的疑问去学习")]),a._v(" "),t("h2",{attrs:{id:"问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[a._v("#")]),a._v(" 问题")]),a._v(" "),t("p",[a._v("1、 go run\n我们上移目录层级，到 "),t("code",[a._v("$GOPATH/src")]),a._v(" 下，执行 "),t("code",[a._v("go run gin-blog/main.go")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[$ src]# go run gin-blog/main.go\n2018/03/12 16:06:13 Fail to parse 'conf/app.ini': open conf/app.ini: no such file or directory\nexit status 1\n")])])]),t("p",[a._v("2、 go build，执行 "),t("code",[a._v("./gin-blog/main")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[$ src]# ./gin-blog/main\n2018/03/12 16:49:35 Fail to parse 'conf/app.ini': open conf/app.ini: no such file or directory\n")])])]),t("p",[a._v("这时候你要打一个大大的问号，就是我的程序读取到什么地方去了")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("我们通过分析得知，"),t("strong",[t("code",[a._v("Golang")]),a._v("的相对路径是相对于执行命令时的目录")]),a._v("；自然也就读取不到了")]),a._v(" "),t("h2",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[a._v("#")]),a._v(" 思考")]),a._v(" "),t("p",[a._v("既然已经知道问题的所在点，我们就可以寻思做点什么 : )")]),a._v(" "),t("p",[a._v("我们想到相对路径是相对执行命令的目录，那么我们获取可执行文件的地址，拼接起来不就好了吗？")]),a._v(" "),t("h2",{attrs:{id:"实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[a._v("#")]),a._v(" 实践")]),a._v(" "),t("p",[a._v("我们编写"),t("strong",[a._v("获取当前可执行文件路径的方法")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('import (\n\t"path/filepath"\n\t"os"\n\t"os/exec"\n\t"string"\n)\n\nfunc GetAppPath() string {\n    file, _ := exec.LookPath(os.Args[0])\n    path, _ := filepath.Abs(file)\n    index := strings.LastIndex(path, string(os.PathSeparator))\n\n    return path[:index]\n}\n')])])]),t("p",[a._v("将其放到启动代码处查看路径")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("log.Println(GetAppPath())\n")])])]),t("p",[a._v("我们分别执行以下两个命令，查看输出结果\n1、 go run")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ go run main.go\n2018/03/12 18:45:40 /tmp/go-build962610262/b001/exe\n")])])]),t("p",[a._v("2、 go build")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("$ ./main\n2018/03/12 18:49:44 $GOPATH/src/gin-blog\n\n")])])]),t("h2",{attrs:{id:"剖析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#剖析"}},[a._v("#")]),a._v(" 剖析")]),a._v(" "),t("p",[a._v("我们聚焦在 "),t("code",[a._v("go run")]),a._v(" 的输出结果上，发现它是一个临时文件的地址，这是为什么呢？")]),a._v(" "),t("p",[a._v("在"),t("code",[a._v("go help run")]),a._v("中，我们可以看到")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('Run compiles and runs the main package comprising the named Go source files.\nA Go source file is defined to be a file ending in a literal ".go" suffix.\n')])])]),t("p",[a._v("也就是 "),t("code",[a._v("go run")]),a._v(" 执行时会将文件放到 "),t("code",[a._v("/tmp/go-build...")]),a._v(" 目录下，编译并运行")]),a._v(" "),t("p",[a._v("因此"),t("code",[a._v("go run main.go")]),a._v("出现"),t("code",[a._v("/tmp/go-build962610262/b001/exe")]),a._v("结果也不奇怪了，因为它已经跑到临时目录下去执行可执行文件了")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("这就已经很清楚了，那么我们想想，会出现哪些问题呢")]),a._v(" "),t("ul",[t("li",[a._v("依赖相对路径的文件，出现路径出错的问题")]),a._v(" "),t("li",[t("code",[a._v("go run")]),a._v(" 和 "),t("code",[a._v("go build")]),a._v(" 不一样，一个到临时目录下执行，一个可手动在编译后的目录下执行，路径的处理方式会不同")]),a._v(" "),t("li",[a._v("不断"),t("code",[a._v("go run")]),a._v("，不断产生新的临时文件")])]),a._v(" "),t("p",[a._v("这其实就是"),t("strong",[a._v("根本原因")]),a._v("了，因为 "),t("code",[a._v("go run")]),a._v(" 和 "),t("code",[a._v("go build")]),a._v(" 的编译文件执行路径并不同，执行的层级也有可能不一样，自然而然就出现各种读取不到的奇怪问题了")]),a._v(" "),t("h2",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),t("p",[t("strong",[a._v("一、获取编译后的可执行文件路径")])]),a._v(" "),t("p",[a._v("1、 将配置文件的相对路径与"),t("code",[a._v("GetAppPath()")]),a._v("的结果相拼接，可解决"),t("code",[a._v("go build main.go")]),a._v("的可执行文件跨目录执行的问题（如："),t("code",[a._v("./src/gin-blog/main")]),a._v("）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('import (\n\t"path/filepath"\n\t"os"\n\t"os/exec"\n\t"string"\n)\n\nfunc GetAppPath() string {\n    file, _ := exec.LookPath(os.Args[0])\n    path, _ := filepath.Abs(file)\n    index := strings.LastIndex(path, string(os.PathSeparator))\n\n    return path[:index]\n}\n')])])]),t("p",[a._v("但是这种方式，对于"),t("code",[a._v("go run")]),a._v("依旧无效，这时候就需要2来补救")]),a._v(" "),t("p",[a._v("2、 通过传递参数指定路径，可解决"),t("code",[a._v("go run")]),a._v("的问题")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('package main\n\nimport (\n    "flag"\n    "fmt"\n)\n\nfunc main() {\n    var appPath string\n    flag.StringVar(&appPath, "app-path", "app-path")\n    flag.Parse()\n    fmt.Printf("App path: %s", appPath)\n}\n')])])]),t("p",[a._v("运行")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('go run main.go --app-path "Your project address"\n')])])]),t("p",[t("strong",[a._v("二、增加"),t("code",[a._v("os.Getwd()")]),a._v("进行多层判断")])]),a._v(" "),t("p",[a._v("参见 "),t("a",{attrs:{href:"https://github.com/astaxie/beego/blob/master/config.go#L133-L146",target:"_blank",rel:"noopener noreferrer"}},[a._v("beego"),t("OutboundLink")],1),a._v(" 读取 "),t("code",[a._v("app.conf")]),a._v(" 的代码")]),a._v(" "),t("p",[a._v("该写法可兼容 "),t("code",[a._v("go build")]),a._v(" 和在项目根目录执行 "),t("code",[a._v("go run")]),a._v(" ，但是若跨目录执行 "),t("code",[a._v("go run")]),a._v(" 就不行")]),a._v(" "),t("p",[t("strong",[a._v("三、配置全局系统变量")])]),a._v(" "),t("p",[a._v("我们可以通过"),t("code",[a._v("os.Getenv")]),a._v("来获取系统全局变量，然后与相对路径进行拼接")]),a._v(" "),t("p",[a._v("1、 设置项目工作区")]),a._v(" "),t("p",[a._v("简单来说，就是设置项目（应用）的工作路径，然后与配置文件、日志文件等相对路径进行拼接，达到相对的绝对路径来保证路径一致")]),a._v(" "),t("p",[a._v("参见 "),t("a",{attrs:{href:"https://github.com/gogits/gogs/blob/master/pkg/setting/setting.go#L351",target:"_blank",rel:"noopener noreferrer"}},[a._v("gogs"),t("OutboundLink")],1),a._v(" 读取"),t("code",[a._v("GOGS_WORK_DIR")]),a._v("进行拼接的代码")]),a._v(" "),t("p",[a._v("2、 利用系统自带变量")]),a._v(" "),t("p",[a._v("简单来说就是通过系统自带的全局变量，例如"),t("code",[a._v("$HOME")]),a._v("等，将配置文件存放在"),t("code",[a._v("$HOME/conf")]),a._v("或"),t("code",[a._v("/etc/conf")]),a._v("下")]),a._v(" "),t("p",[a._v("这样子就能更加固定的存放配置文件，"),t("strong",[a._v("不需要额外去设置一个环境变量")])]),a._v(" "),t("p",[a._v("（这点今早与一位SFer讨论了一波，感谢）")]),a._v(" "),t("h2",{attrs:{id:"拓展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[a._v("#")]),a._v(" 拓展")]),a._v(" "),t("p",[t("code",[a._v("go test")]),a._v(" 在一些场景下也会遇到路径问题，因为"),t("code",[a._v("go test")]),a._v("只能够在当前目录执行，所以在执行测试用例的时候，你的执行目录已经是测试目录了")]),a._v(" "),t("p",[a._v("需要注意的是，如果采用获取外部参数的办法，用 "),t("code",[a._v("os.args")]),a._v(" 时，"),t("code",[a._v("go test -args")]),a._v(" 和 "),t("code",[a._v("go run")]),a._v("、"),t("code",[a._v("go build")]),a._v(" 会有命令行参数位置的不一致问题")]),a._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),t("p",[a._v("这三种解决方案，在目前可见的开源项目或介绍中都能找到这些的身影")]),a._v(" "),t("p",[a._v("优缺点也是显而易见的，我认为应在"),t("strong",[a._v("不同项目选定合适的解决方案")]),a._v("即可")]),a._v(" "),t("p",[a._v("建议大家不要强依赖读取配置文件的模块，应当将其“堆积木”化，"),t("strong",[a._v("需要什么配置才去注册什么配置变量")]),a._v("，可以解决一部分的问题")]),a._v(" "),t("p",[a._v("大家又有什么想法呢，一起讨论一波？")])])}),[],!1,null,null,null);e.default=v.exports}}]);