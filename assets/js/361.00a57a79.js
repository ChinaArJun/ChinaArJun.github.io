(window.webpackJsonp=window.webpackJsonp||[]).push([[361],{939:function(t,a,e){"use strict";e.r(a);var o=e(44),s=Object(o.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"go-modules-和-goproxy-cn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#go-modules-和-goproxy-cn"}},[t._v("#")]),t._v(" Go Modules 和 goproxy.cn")]),t._v(" "),e("h3",{attrs:{id:"go-module-概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#go-module-概念"}},[t._v("#")]),t._v(" Go Module 概念")]),t._v(" "),e("p",[t._v("Modules 模块\nmodule 是项目相关 Go 包的一个集合，它们作为一个独立单元将项目所需的依赖包版本化。")]),t._v(" "),e("p",[t._v("module 记录精确的依赖项并创建可重复的编译。")]),t._v(" "),e("p",[t._v("总结仓库，模块和包之间的关系：")]),t._v(" "),e("ul",[e("li",[t._v("仓库包含一个或多个 Go 模块。")]),t._v(" "),e("li",[t._v("每个模块包含一个或多个 Go 包")]),t._v(" "),e("li",[t._v("每个包由一个目录中的一个或多个 Go 源文件组成\nmodule 必须根据semver进行语义化版本，通常采用v(major).(minor).(patch)的形式，例如 v0.1.0，v1.2.3 或 v1.5.0-rc.1。")])]),t._v(" "),e("p",[t._v("go.mod\n模块由 Go 源文件树定义，并在源文件树的根目录中包含 go.mod 文件。模块源代码可能位于 GOPATH 之外。go.mod 文件有四个指令：module，require，replace，exclude。")]),t._v(" "),e("p",[t._v("这是一个定义模块github.com/my/thing的示例go.mod文件：")]),t._v(" "),e("h3",{attrs:{id:"如何使用-module"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-module"}},[t._v("#")]),t._v(" 如何使用 Module")]),t._v(" "),e("ol",[e("li",[t._v("切换到 GOPATH 之外的目录：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ cd <project path outside $GOPATH/src>         # cd ~/projects/hello\n")])])]),e("ul",[e("li",[t._v("需要注意的是，在 GOPATH 目录之外无需设置GO111MODULE环境变量来激活模块。")]),t._v(" "),e("li",[t._v("或者，如果你想在 GOPATH 中运行：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ export GO111MODULE=on                         # manually active module mode\n$ cd $GOPATH/src/<project path>                 # cd $GOPATH/src/you/hello\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("初始化模块：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go mod init  \n")])])]),e("p",[t._v("此步骤从现有的 dep Gopkg.lock 文件或其他九种支持的依赖文件（类似glide.lock详细戳），为 go.mod 添加 require 语句以匹配现有配置。")]),t._v(" "),e("p",[t._v("go mod init通常能够使用辅助数据（例如 VCS 元数据）来自动确定相应的模块路径，但是如果go mod init表明它不能自动确定模块路径，则你需要以其他方式覆盖 path，你可以提供模块路径作为go mod init的可选参数，例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go mod init github.com/my/repo\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("构建模块。在模块的根目录执行，./...模式匹配当前模块中的所有包。 go build 将根据需要自动添加没有的依赖项或未转换的依赖项")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go build ./...\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("按配置测试模块，以确保它适用于所选版本：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go test ./...\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("（可选）运行模块的测试以及所有直接和间接依赖项的测试以检查兼容性：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ go test all\n")])])]),e("ul",[e("li",[t._v("一切都准备好了，但是go mod下载的包放在哪儿呢，因为我用的gvm。下面这个命令将会帮到你")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("go mod download -json\n")])])]),e("h3",{attrs:{id:"go-mod-proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#go-mod-proxy"}},[t._v("#")]),t._v(" go mod proxy")]),t._v(" "),e("ul",[e("li",[t._v("在之前如果要下被墙的包需要配mirror，ss proxy等等各种手段，使用了module proxy之后，一切变得简单+ 起来。启用proxy只需两步")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export GO111MODULE=on \nexport GOPROXY=https://goproxy.cn\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);