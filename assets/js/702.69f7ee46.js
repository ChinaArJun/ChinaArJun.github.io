(window.webpackJsonp=window.webpackJsonp||[]).push([[702],{1303:function(t,a,s){"use strict";s.r(a);var e=s(44),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),s("p",[t._v("先说前端静态资源的部署。在现有的打包方案下，为了充分利用 http 的永久缓存，打包后静态资源文件一般会戳个 hash 值。这样打包后的某个文件会长这个样子: "),s("code",[t._v("main.a3b4c5.js")]),t._v("。")]),t._v(" "),s("p",[t._v("又为了充分利用 CDN 对静态资源的加速，我们会把静态资源扔到对象存储 OSS 上，然后使用 CDN 对 OSS 的静态资源加速。于是，久而久之，OSS 上堆积的文件也越来越多")]),t._v(" "),s("div",{staticClass:"language-txt extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("project/static/main.a3b4c5.js\nproject/static/main.a3b4xs.js\nproject/static/main.axx8xs.js\nproject/static/main.8abc09.js\nproject/static/main.8bayd0.js\n...\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);