(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{714:function(t,s,a){"use strict";a.r(s);var n=a(44),_=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_01-对称加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_01-对称加密"}},[t._v("#")]),t._v(" 01 - 对称加密")]),t._v(" "),a("h3",{attrs:{id:"_1-1-基础知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-基础知识点"}},[t._v("#")]),t._v(" 1.1 基础知识点")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("知识点大纲介绍")]),t._v(" "),a("ul",[a("li",[t._v("密码的基础概念")]),t._v(" "),a("li",[t._v("对称加密")]),t._v(" "),a("li",[t._v("非对称加密")]),t._v(" "),a("li",[t._v("单向散列函数\n"),a("ul",[a("li",[t._v("哈希函数")])])]),t._v(" "),a("li",[t._v("消息认证码")]),t._v(" "),a("li",[t._v("数字签名")]),t._v(" "),a("li",[t._v("证书")]),t._v(" "),a("li",[t._v("ssl/tls - https")])])]),t._v(" "),a("li",[a("p",[t._v("为什么要加密, 以及解决方案")]),t._v(" "),a("p",[t._v("保证数据安全")])]),t._v(" "),a("li",[a("p",[t._v("加密三要素")]),t._v(" "),a("ul",[a("li",[t._v("明文/密文")]),t._v(" "),a("li",[t._v("秘钥\n"),a("ul",[a("li",[t._v("定长的字符串")]),t._v(" "),a("li",[t._v("需要根据加密算法确定其长度")])])]),t._v(" "),a("li",[t._v("算法\n"),a("ul",[a("li",[t._v("加密算法")]),t._v(" "),a("li",[t._v("解密算法")]),t._v(" "),a("li",[t._v("加密算法和解密算法有可能是互逆的, 也有可能相同")])])])])]),t._v(" "),a("li",[a("p",[t._v("常用的两种加密方式")]),t._v(" "),a("ul",[a("li",[t._v("对称加密\n"),a("ul",[a("li",[t._v("秘钥: 加密解密使用的是同一个秘钥, 秘钥有一个")]),t._v(" "),a("li",[t._v("特点\n"),a("ul",[a("li",[t._v("双方向保证机密性")]),t._v(" "),a("li",[t._v("加密效率高, 适合加密大数据, 大文件")]),t._v(" "),a("li",[t._v("加密强度不高, 相对于非对称加密")])])])])]),t._v(" "),a("li",[t._v("非对称加密\n"),a("ul",[a("li",[t._v("秘钥: 加密解密使用的不同的秘钥, 秘钥有两个, 需要使用秘钥生成算法, 得到密钥对\n"),a("ul",[a("li",[t._v("公钥 - 可以公开的秘钥\n"),a("ul",[a("li",[t._v("公钥加密数据, 解密需要使用私钥")])])]),t._v(" "),a("li",[t._v("私钥 - 需要妥善保管的秘钥, 知道的人越少越好\n"),a("ul",[a("li",[t._v("私钥加密, 公钥解密")])])])])]),t._v(" "),a("li",[t._v("特点:\n"),a("ul",[a("li",[t._v("数据的机密性只能单方向保证")]),t._v(" "),a("li",[t._v("加密效率低, 适合加密少量数据")]),t._v(" "),a("li",[t._v("加密强度高, 相对于对称加密")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("凯撒密码")]),t._v(" "),a("p",[t._v("恺撒密码（Caesar cipher）是一种相传尤利乌斯·恺撒曾使用过的密码。恺撒于公元前100年左右诞生于古罗马，是一位著名的军事统帅。")]),t._v(" "),a("blockquote",[a("p",[a("font",{attrs:{color:"red"}},[t._v("恺撤密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密的")]),t._v("。")],1)]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day01/1538906583082.png",alt:"1538906583082"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("凯撒密码加解密公式")]),t._v(" "),a("ul",[a("li",[t._v("加密")])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day01/513169b7dcabfc4de6d4fcbc03e613434244e917.svg",alt:""}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("解密")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day01/110911f42b858bdf1bec629ae41b5b88b00859e2.svg",alt:""}})])])])]),t._v(" "),a("li",[a("p",[t._v("凯撒密码中的加密三要素")]),t._v(" "),a("ul",[a("li",[t._v("明文/密文\n"),a("ul",[a("li",[t._v("明文: 小写字母表中的数据")]),t._v(" "),a("li",[t._v("密文: 大写字母表中的数据")])])]),t._v(" "),a("li",[t._v("秘钥\n"),a("ul",[a("li",[t._v("按照上图秘钥为3")])])]),t._v(" "),a("li",[t._v("算法\n"),a("ul",[a("li",[t._v("加密: +3")]),t._v(" "),a("li",[t._v("解密: -3")])])])])]),t._v(" "),a("li",[a("p",[t._v("凯撒密码的安全性")]),t._v(" "),a("p",[t._v("不安全")])])])]),t._v(" "),a("li",[a("p",[t._v("密码信息安全常识")]),t._v(" "),a("ul",[a("li",[t._v("不要使用保密的密码算法（普通公司和个人）")]),t._v(" "),a("li",[t._v("使用低强度的密码比不进行任何加密更危险")]),t._v(" "),a("li",[t._v("任何密码总有一天都会被破解")]),t._v(" "),a("li",[t._v("密码只是信息安全的一部分")])])]),t._v(" "),a("li",[a("p",[t._v("密码信息威胁")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day01/1538907602932.png",alt:"1538907602932"}})]),t._v(" "),a("p",[t._v("思考：信息安全处理必须要具备哪些特性？")])])]),t._v(" "),a("h3",{attrs:{id:"_1-2-对称加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-对称加密"}},[t._v("#")]),t._v(" 1.2 对称加密")]),t._v(" "),a("blockquote",[a("p",[t._v("以分组为单位进行处理的密码算法称为"),a("strong",[t._v("分组密码（blockcipher）")])])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("编码的概念")]),t._v(" "),a("p",[t._v("G = 1024m")]),t._v(" "),a("p",[t._v("m = 1024kbyte")]),t._v(" "),a("p",[t._v("byte  = 8bit")]),t._v(" "),a("p",[t._v("bit 0/1")]),t._v(" "),a("blockquote",[a("p",[t._v("计算机的操作对象并不是文字，而是由0和1排列而成的"),a("strong",[t._v("比特序列")]),t._v("。")]),t._v(" "),a("p",[t._v("将现实世界中的东西映射为比特序列的操作称为"),a("strong",[t._v("编码（encoding）")]),t._v("。")]),t._v(" "),a("p",[t._v("加密 -> 编码")]),t._v(" "),a("p",[t._v("解密 -> 解码")])]),t._v(" "),a("p",[t._v("hello world -> 比特序列")]),t._v(" "),a("p",[t._v("h -> int 104 ->")])]),t._v(" "),a("li",[a("p",[t._v("DES   --   Data Encryption Standard")]),t._v(" "),a("ul",[a("li",[t._v("现在使用DES方式加密，数据还安全吗？\n"),a("ul",[a("li",[t._v("不安全, 已经被破解了")])])]),t._v(" "),a("li",[t._v("是不是分组密码？\n"),a("ul",[a("li",[t._v("是, 先对数据进行分组, 然后在加密或解密")])])]),t._v(" "),a("li",[t._v("DES的分组长度?\n"),a("ul",[a("li",[t._v("8byte == 64bit")])])]),t._v(" "),a("li",[t._v("DES的秘钥长度?\n"),a("ul",[a("li",[t._v("56bit秘钥长度+8bit错误检测标志位 = 64bit == 8byte")])])])])]),t._v(" "),a("li",[a("p",[t._v("3DES   --   Triple-DES")]),t._v(" "),a("ul",[a("li",[t._v("3DES安全吗?\n"),a("ul",[a("li",[t._v("安全, 但是效率低")])])]),t._v(" "),a("li",[t._v("算法描述?\n"),a("ul",[a("li",[t._v("进行了3次des加密")])])]),t._v(" "),a("li",[t._v("是不是分组密码?\n"),a("ul",[a("li",[t._v("是")])])]),t._v(" "),a("li",[t._v("3DES分组长度?\n"),a("ul",[a("li",[t._v("8字节")])])]),t._v(" "),a("li",[t._v("3DES秘钥长度?\n"),a("ul",[a("li",[t._v("24字节, 在算法内部会被平均分成3份")])])]),t._v(" "),a("li",[t._v("3DES加密过程?\n"),a("ul",[a("li",[t._v("秘钥1 -> 加密, 秘钥2 -> 解密, 秘钥3 -> 加密")])])]),t._v(" "),a("li",[t._v("3DES解密过程?\n"),a("ul",[a("li",[t._v("秘钥1 -> 解密, 秘钥2 -> 加密, 秘钥3 -> 解密")])])])])]),t._v(" "),a("li",[a("p",[t._v("AES   --   Advanced Encryption Standard")]),t._v(" "),a("ul",[a("li",[t._v("AES安全吗?\n"),a("ul",[a("li",[t._v("安全, 效率高, 推荐使用的")])])]),t._v(" "),a("li",[t._v("是不是分组密码?\n"),a("ul",[a("li",[t._v("是")])])]),t._v(" "),a("li",[t._v("AES分组长度?\n"),a("ul",[a("li",[t._v("128bit = 16字节")])])]),t._v(" "),a("li",[t._v("AES秘钥长度?\n"),a("ul",[a("li",[t._v("128bit = 16字节")]),t._v(" "),a("li",[t._v("192bit = 24字节")]),t._v(" "),a("li",[t._v("256bit = 32字节")]),t._v(" "),a("li",[t._v("go中的秘钥长度只能是16字节")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_1-3-分组密码的模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-分组密码的模式"}},[t._v("#")]),t._v(" 1.3 分组密码的模式")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("按位异或")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一步需要将数据转换为二进制")])]),t._v(" "),a("li",[a("p",[t._v("按位异或操作符: ^")])]),t._v(" "),a("li",[a("p",[t._v("两个标志位进行按位异或操作:")]),t._v(" "),a("ul",[a("li",[t._v("相同为0, 不同为1")])])]),t._v(" "),a("li",[a("p",[t._v("举例:")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("按位异或一次\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("按位异或两侧\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\na "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\nb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v("\na 和 b按位异或"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("次 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 加密\n得到的结果再次和 b 按位异或 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 解密\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("ECB - Electronic Code Book, 电子密码本模式")]),t._v(" "),a("ul",[a("li",[t._v("特点: 简单, 效率高, 密文有规律, 容易被破解")]),t._v(" "),a("li",[t._v("最后一个明文分组必须要填充\n"),a("ul",[a("li",[t._v("des/3des -> 最后一个分组填充满8字节")]),t._v(" "),a("li",[t._v("aes -> 最后一个分组填充满16字节")])])]),t._v(" "),a("li",[t._v("不需要初始化向量")])])]),t._v(" "),a("li",[a("p",[t._v("CBC - Cipher Block Chaining, 密码块链模式")]),t._v(" "),a("ul",[a("li",[t._v("特点: 密文没有规律, 经常使用的加密方式")]),t._v(" "),a("li",[t._v("最后一个明文分组需要填充\n"),a("ul",[a("li",[t._v("des/3des -> 最后一个分组填充满8字节")]),t._v(" "),a("li",[t._v("aes -> 最后一个分组填充满16字节")])])]),t._v(" "),a("li",[t._v("需要一个初始化向量 - 一个数组\n"),a("ul",[a("li",[t._v("数组的长度: 与明文分组相等")]),t._v(" "),a("li",[t._v("数据来源: 负责加密的人的提供的")]),t._v(" "),a("li",[t._v("加解密使用的初始化向量值必须相同")])])])])]),t._v(" "),a("li",[a("p",[t._v("CFB - Cipher FeedBack, 密文反馈模式")]),t._v(" "),a("ul",[a("li",[t._v("特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文")]),t._v(" "),a("li",[t._v("需要一个初始化向量 - 一个数组\n"),a("ul",[a("li",[t._v("数组的长度: 与明文分组相等")]),t._v(" "),a("li",[t._v("数据来源: 负责加密的人的提供的")]),t._v(" "),a("li",[t._v("加解密使用的初始化向量值必须相同")])])]),t._v(" "),a("li",[t._v("不需要填充")])])]),t._v(" "),a("li",[a("p",[t._v("OFB - Output-Feedback, 输出反馈模式")]),t._v(" "),a("ul",[a("li",[t._v("特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文")]),t._v(" "),a("li",[t._v("需要一个初始化向量 - 一个数组\n"),a("ul",[a("li",[t._v("数组的长度: 与明文分组相等")]),t._v(" "),a("li",[t._v("数据来源: 负责加密的人的提供的")]),t._v(" "),a("li",[t._v("加解密使用的初始化向量值必须相同")])])]),t._v(" "),a("li",[t._v("不需要填充")])])]),t._v(" "),a("li",[a("p",[t._v("CTR - CounTeR, 计数器模式")]),t._v(" "),a("ul",[a("li",[t._v("特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文")]),t._v(" "),a("li",[t._v("不需要初始化向量\n"),a("ul",[a("li",[t._v("go接口中的iv可以理解为随机数种子, iv的长度 == 明文分组的长度")])])]),t._v(" "),a("li",[t._v("不需要填充")])])]),t._v(" "),a("li",[a("p",[t._v("最后一个明文分组的填充")]),t._v(" "),a("ul",[a("li",[t._v("使用cbc, ecb需要填充\n"),a("ul",[a("li",[t._v("要求:\n"),a("ul",[a("li",[t._v("明文分组中进行了填充, 然后加密")]),t._v(" "),a("li",[t._v("解密密文得到明文, 需要把填充的字节删除")])])])])]),t._v(" "),a("li",[t._v("使用 ofb, cfb, ctr不需要填充")])])]),t._v(" "),a("li",[a("p",[t._v("初始化向量 - IV")]),t._v(" "),a("ul",[a("li",[t._v("ecb, ctr模式不需要初始化向量")]),t._v(" "),a("li",[t._v("cbc, ofc, cfb需要初始化向量\n"),a("ul",[a("li",[t._v("初始化向量的长度\n"),a("ul",[a("li",[t._v("des/3des -> 8字节")]),t._v(" "),a("li",[t._v("aes -> 16字节")])])]),t._v(" "),a("li",[t._v("加解密使用的初始化向量相同")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_1-4-对称加密在go中的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-对称加密在go中的实现"}},[t._v("#")]),t._v(" 1.4 对称加密在go中的实现")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("des")])]),t._v(" "),a("li",[a("p",[t._v("3des")])]),t._v(" "),a("li",[a("p",[t._v("aes")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 加密流程:")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(". 创建一个底层使用des/3des/aes的密码接口\n\t"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"crypto/des"')]),t._v("\n\tfunc NewCipher"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cipher.Block, error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -- des")]),t._v("\n\tfunc NewTripleDESCipher"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cipher.Block, error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -- 3des")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"crypto/aes"')]),t._v("\n\tfunc NewCipher"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cipher.Block, error"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# == aes")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(". 如果使用的是cbc/ecb分组模式需要对明文分组进行填充\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(". 创建一个密码分组模式的接口对象\n\t- cbc\n\tfunc NewCBCEncrypter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b Block, iv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" BlockMode "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 加密")]),t._v("\n\t- cfb\n\tfunc NewCFBEncrypter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block Block, iv "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("byte"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Stream "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 加密")]),t._v("\n\t- ofb\n\t- ctr\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(". 加密, 得到密文\n\t\n")])])])])]),t._v(" "),a("h2",{attrs:{id:"_02-非对称加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_02-非对称加密"}},[t._v("#")]),t._v(" 02 - 非对称加密")]),t._v(" "),a("h3",{attrs:{id:"_1-对称加密的弊端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-对称加密的弊端"}},[t._v("#")]),t._v(" 1.  对称加密的弊端'")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("秘钥分发困难")])]),t._v(" "),a("li",[a("p",[t._v("可以通过非对称加密完成秘钥的分发")]),t._v(" "),a("blockquote",[a("p",[t._v("https")]),t._v(" "),a("p",[t._v("Alice 和 Bob通信, Alice给bob发送数据, 使用对称加密的方式")]),t._v(" "),a("ol",[a("li",[t._v("生成一个非对称的秘钥对, bob生成")]),t._v(" "),a("li",[t._v("bob将公钥发送给alice")]),t._v(" "),a("li",[t._v("alice生成一个用于对称加密的秘钥")]),t._v(" "),a("li",[t._v("alice使用bob的公钥就对称加密的秘钥进行加密, 并且发送给bob")]),t._v(" "),a("li",[t._v("bob使用私钥就数据解密, 得到对称加密的秘钥")]),t._v(" "),a("li",[t._v("通信的双方使用写好的秘钥进行对称加密数据加密")])])])])]),t._v(" "),a("h3",{attrs:{id:"_2-非对称加密的秘钥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-非对称加密的秘钥"}},[t._v("#")]),t._v(" 2. 非对称加密的秘钥")]),t._v(" "),a("ul",[a("li",[t._v("不存在秘钥分发困难的问题")])]),t._v(" "),a("h4",{attrs:{id:"_2-1-场景分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-场景分析"}},[t._v("#")]),t._v(" 2.1 场景分析")]),t._v(" "),a("p",[t._v("数据对谁更重要, 谁就拿私钥")]),t._v(" "),a("ul",[a("li",[t._v("直观上看: 私钥比公钥长")]),t._v(" "),a("li",[t._v("使用第三方工具生成密钥对: 公钥文件xxx.pub xxx")])]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("通信流程, 信息加密  （A写数据, 发送给B, 信息只允许B读）")]),t._v(" "),a("p",[t._v("A: 公钥")]),t._v(" "),a("p",[t._v("B: 私钥")])]),t._v(" "),a("li",[a("p",[t._v("登录认证 （客户端要登录, 连接服务器, 向服务器请求个人数据）")]),t._v(" "),a("p",[t._v("客户端:  私钥")]),t._v(" "),a("p",[t._v("服务器:  公钥")])]),t._v(" "),a("li",[a("p",[t._v("数字签名（表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面）")]),t._v(" "),a("ul",[a("li",[t._v("发送信息的人:   私钥")]),t._v(" "),a("li",[t._v("收到信息的人:   公钥")])])]),t._v(" "),a("li",[a("p",[t._v("网银U盾")]),t._v(" "),a("ul",[a("li",[t._v("个人: 私钥")]),t._v(" "),a("li",[t._v("银行拿公钥")])])])])]),t._v(" "),a("h3",{attrs:{id:"_3-使用rsa非对称加密通信流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用rsa非对称加密通信流程"}},[t._v("#")]),t._v(" 3. 使用RSA非对称加密通信流程")]),t._v(" "),a("blockquote",[a("p",[t._v("要求: Alice 给 bob发送数据, 保证数据信息只有bob能看到")])]),t._v(" "),a("h3",{attrs:{id:"_4-生成rsa的秘钥对"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-生成rsa的秘钥对"}},[t._v("#")]),t._v(" 4. 生成RSA的秘钥对")]),t._v(" "),a("h4",{attrs:{id:"_4-1-一些概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-一些概念"}},[t._v("#")]),t._v(" 4.1 一些概念")]),t._v(" "),a("ol",[a("li",[t._v("x509证书规范、pem、base64\n"),a("ul",[a("li",[t._v("pem编码规范 - 数据加密")]),t._v(" "),a("li",[t._v("base64 - 对数据编码, 可逆\n"),a("ul",[a("li",[t._v("不管原始数据是什么, 将原始数据使用64个字符来替代\n"),a("ul",[a("li",[t._v("a-z  A-Z 0-9 + /")])])])])])])]),t._v(" "),a("li",[t._v("ASN.1抽象语法标记")]),t._v(" "),a("li",[t._v("PKCS1标准")])]),t._v(" "),a("h4",{attrs:{id:"_4-2-密钥对生成流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-密钥对生成流程"}},[t._v("#")]),t._v(" 4.2 密钥对生成流程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("生成私钥操作流程概述")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("使用rsa中的GenerateKey方法生成私钥")]),t._v(" "),a("p",[t._v("func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error)")]),t._v(" "),a("ul",[a("li",[t._v('rand.Reader   -> import "crypto/rand"')]),t._v(" "),a("li",[t._v("1024 的整数倍 - 建议")])])]),t._v(" "),a("li",[a("p",[t._v("通过x509标准将得到的ras私钥序列化为ASN.1 的 DER编码字符串")]),t._v(" "),a("p",[t._v("func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte")])]),t._v(" "),a("li",[a("p",[t._v("将私钥字符串设置到pem格式块中")]),t._v(" "),a("p",[t._v("初始化一个pem.Block块")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Block "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Type    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// 得自前言的类型（如"RSA PRIVATE KEY"）')]),t._v("\n    Headers "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可选的头项")]),t._v("\n    Bytes   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 内容解码后的数据，一般是DER编码的ASN.1结构")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("通过pem将设置好的数据进行编码, 并写入磁盘文件中")]),t._v(" "),a("p",[t._v("func Encode(out io.Writer, b *Block) error")]),t._v(" "),a("ul",[a("li",[t._v("out - 准备一个文件指针")])])])])])]),t._v(" "),a("li",[a("p",[t._v("生成公钥操作流程")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("从得到的私钥对象中将公钥信息取出")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" PrivateKey "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    PublicKey            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 公钥")]),t._v("\n    D         "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("big"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Int   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 私有的指数")]),t._v("\n    Primes    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("big"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Int "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// N的素因子，至少有两个")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 包含预先计算好的值，可在某些情况下加速私钥的操作")]),t._v("\n    Precomputed PrecomputedValues\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("通过x509标准将得到 的rsa公钥序列化为字符串")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)\n")])])])]),t._v(" "),a("li",[a("p",[t._v("将公钥字符串设置到pem格式块中")]),t._v(" "),a("p",[t._v('type Block struct {\nType    string            // 得自前言的类型（如"RSA PRIVATE KEY"）\nHeaders map[string]string // 可选的头项\nBytes   []byte            // 内容解码后的数据，一般是DER编码的ASN.1结构\n}')])]),t._v(" "),a("li",[a("p",[t._v("通过pem将设置好的数据进行编码, 并写入磁盘文件")]),t._v(" "),a("p",[t._v("func Encode(out io.Writer, b *Block) error")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_5-rsa加解密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-rsa加解密"}},[t._v("#")]),t._v(" 5. RSA加解密")]),t._v(" "),a("h4",{attrs:{id:"_5-1-rsa加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-rsa加密"}},[t._v("#")]),t._v(" 5.1 RSA加密")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("将公钥文件中的公钥读出, 得到使用pem编码的字符串")]),t._v(" "),a("p",[t._v("-- 读文件")])]),t._v(" "),a("li",[a("p",[t._v("将得到的字符串解码")]),t._v(" "),a("p",[t._v("-- pem.Decode")])]),t._v(" "),a("li",[a("p",[t._v("使用x509将编码之后的公钥解析出来")]),t._v(" "),a("p",[t._v("-- func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error)")])]),t._v(" "),a("li",[a("p",[t._v("使用得到的公钥通过rsa进行数据加密")])])])]),t._v(" "),a("h4",{attrs:{id:"_5-2-rsa解密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-rsa解密"}},[t._v("#")]),t._v(" 5.2 RSA解密")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("将私钥文件中的私钥读出, 得到使用pem编码的字符串")]),t._v(" "),a("li",[t._v("将得到的字符串解码")]),t._v(" "),a("li",[t._v("使用x509将编码之后的私钥解析出来")]),t._v(" "),a("li",[t._v("使用得到的私钥通过rsa进行数据解密")])])]),t._v(" "),a("h3",{attrs:{id:"_6-哈希算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-哈希算法"}},[t._v("#")]),t._v(" 6. 哈希算法")]),t._v(" "),a("h3",{attrs:{id:"_6-1-概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-概念"}},[t._v("#")]),t._v(" 6.1 概念")]),t._v(" "),a("p",[t._v("称谓: 单向散列函数, 哈希函数, 杂凑函数, 消息摘要函数")]),t._v(" "),a("p",[t._v("接收的输入: 原像")]),t._v(" "),a("p",[t._v("输出: 散列值, 哈希值, 指纹, 摘要")]),t._v(" "),a("h3",{attrs:{id:"_6-2-单向散列函数特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-单向散列函数特性"}},[t._v("#")]),t._v(" 6.2 单向散列函数特性")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("将任意长度的数据转换成固定长度的数据")])]),t._v(" "),a("li",[a("p",[t._v("很强的抗碰撞性")])]),t._v(" "),a("li",[a("p",[t._v("不可逆")])]),t._v(" "),a("li",[a("p",[t._v("MD4/MD5")]),t._v(" "),a("ul",[a("li",[t._v("不安全")]),t._v(" "),a("li",[t._v("散列值长度: 128bit == 16byte")])])]),t._v(" "),a("li",[a("p",[t._v("sha1")]),t._v(" "),a("ul",[a("li",[t._v("不安全")]),t._v(" "),a("li",[t._v("散列值长度: 160bit == 20byte")])])]),t._v(" "),a("li",[a("p",[t._v("sha2 - 安全")]),t._v(" "),a("ul",[a("li",[t._v("sha224\n"),a("ul",[a("li",[t._v("散列值长度: 224bit == 28byte")])])]),t._v(" "),a("li",[t._v("sha256\n"),a("ul",[a("li",[t._v("散列值长度: 256== 32byte")])])]),t._v(" "),a("li",[t._v("sha384\n"),a("ul",[a("li",[t._v("散列值长度: 384bit == 48byte")])])]),t._v(" "),a("li",[t._v("sha512\n"),a("ul",[a("li",[t._v("散列值长度: 512bit == 64byte")])])])]),t._v(" "),a("h3",{attrs:{id:"_6-3-go中使用单向散列函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-go中使用单向散列函数"}},[t._v("#")]),t._v(" 6.3 go中使用单向散列函数")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一种方式, 直接调用sum")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 适用于数据量比较小的情况")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第二种方式")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1. 创建哈希接口对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("New")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Hash "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误")]),t._v("\n    io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Writer\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 重设hash为无数据输入的状态")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Reset")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回Sum会返回的切片的长度")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回hash底层的块大小；Write方法可以接受任何大小的数据，")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但提供的数据是块大小的倍数时效率更高")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("BlockSize")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Writer "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. 往创建出的哈希对象中添加数据")]),t._v("\nhash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"添加的数据..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nhash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"添加的数据..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nhash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"添加的数据..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nhash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"添加的数据..."')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3. 计算结果, md5就是散列值")]),t._v("\nmd5 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 散列值一般是一个二进制的字符串, 有些字符不可见, 需要格式化")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 格式化为16进制的数字串 - 0-9, a-f")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("EncodeToString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("src "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数据转换完成之后, 长度是原来的2倍")]),t._v("\n\n")])])]),a("ol",[a("li",[t._v("计算一个大文件比如1G文件的散列值")]),t._v(" "),a("li",[t._v("使用udp的方式分发秘钥, 进行一个对称加密的通信\n"),a("ul",[a("li",[t._v("服务器\n"),a("ul",[a("li",[t._v("生成密钥对")]),t._v(" "),a("li",[t._v("公钥发送给客户端")])])]),t._v(" "),a("li",[t._v("客户端\n"),a("ul",[a("li",[t._v("客户端收到了公钥")]),t._v(" "),a("li",[t._v("生成一个秘钥 - 用于对称加密")]),t._v(" "),a("li",[t._v("使用公钥加密, 发送给服务器")])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"对称加密和非对称加密总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对称加密和非对称加密总结"}},[t._v("#")]),t._v(" 对称加密和非对称加密总结")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("概念")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("加密三要素")]),t._v(" "),a("ul",[a("li",[t._v("明文/密文")]),t._v(" "),a("li",[t._v("秘钥")]),t._v(" "),a("li",[t._v("算法")])])]),t._v(" "),a("li",[a("p",[t._v("对称加密和非对称加密")]),t._v(" "),a("ul",[a("li",[t._v("对称加密: 加解密使用同一个秘钥, 1个\n"),a("ul",[a("li",[t._v("效率高")])])]),t._v(" "),a("li",[t._v("非...: 密钥对\n"),a("ul",[a("li",[t._v("公钥加密, 私钥解密")]),t._v(" "),a("li",[t._v("私钥加密, 公钥解密")])])])])]),t._v(" "),a("li",[a("p",[t._v("对称加密中的公开的加密算法")]),t._v(" "),a("ul",[a("li",[t._v("des\n"),a("ul",[a("li",[t._v("分组长度: 8字节")]),t._v(" "),a("li",[t._v("秘钥长度: 8字节")])])]),t._v(" "),a("li",[t._v("3des\n"),a("ul",[a("li",[t._v("分组长度: 8字节")]),t._v(" "),a("li",[t._v("秘钥长度: 24byte")])])]),t._v(" "),a("li",[t._v("aes\n"),a("ul",[a("li",[t._v("分组长度: 16字节")]),t._v(" "),a("li",[t._v("秘钥长度: 16字节, 24字节, 32字节\n"),a("ul",[a("li",[t._v("在go的api中只能使用16字节")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("对称加密的分组模式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("EBC - 不推荐使用")])]),t._v(" "),a("li",[a("p",[t._v("CBC - 常用的方式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("准备的数据:")]),t._v(" "),a("ul",[a("li",[t._v("初始化向量iv - 字符数组")]),t._v(" "),a("li",[t._v("长度 == 明文分组长度")]),t._v(" "),a("li",[t._v("加解密初始化向量值必须相同")]),t._v(" "),a("li",[t._v("秘钥\n"),a("ul",[a("li",[t._v("根据加密算法定")])])])])])]),t._v(" "),a("p",[t._v("===========================")])]),t._v(" "),a("li",[a("p",[t._v("OFB - 不推荐使用")])]),t._v(" "),a("li",[a("p",[t._v("CFB - 不推荐使用")])]),t._v(" "),a("li",[a("p",[t._v("CTR - 推荐使用, 效率最高")])])])])])])]),t._v(" "),a("h2",{attrs:{id:"_03-消息认证码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_03-消息认证码"}},[t._v("#")]),t._v(" 03 - 消息认证码")]),t._v(" "),a("h3",{attrs:{id:"_1-1-消息认证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-消息认证"}},[t._v("#")]),t._v(" 1.1 消息认证")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称为MAC。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day03/1539176665517.png",alt:"1539176665517"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("思考改进方案?")]),t._v(" "),a("p",[t._v("从哈希函数入手")]),t._v(" "),a("p",[t._v("需要将要发送的数据进行哈希运算, 将哈希值和原始数据一并发送")]),t._v(" "),a("p",[t._v("需要在进行哈希运算的时候引入加密的步骤")]),t._v(" "),a("ul",[a("li",[t._v("在alice对数据进行哈希运算的时候引入一个秘钥, 让其参与哈希运算, 生成散列值")]),t._v(" "),a("li",[t._v("bob对数据校验\n"),a("ul",[a("li",[t._v("bob收到原始和散列值之后,\n"),a("ul",[a("li",[t._v("处理原始数据: 通过秘钥和哈希算法对原始数据生成散列值")]),t._v(" "),a("li",[t._v("散列值比较: 生成的散列值 和  接收到的散列值进行比对")])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"_1-2-消息认证码的使用步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-消息认证码的使用步骤"}},[t._v("#")]),t._v(" 1.2 消息认证码的使用步骤")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day03/1539177690828.png",alt:"1539177690828"}})]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("前提条件:\n"),a("ul",[a("li",[t._v("在消息认证码生成的一方和校验的一方, 必须有一个秘钥")]),t._v(" "),a("li",[t._v("双方约定好使用同样的哈希函数对数据进行运算")])])]),t._v(" "),a("li",[t._v("流程:\n"),a("ul",[a("li",[t._v("发送者:\n"),a("ul",[a("li",[t._v("发送原始法消息")]),t._v(" "),a("li",[t._v("将原始消息生成消息认证码\n"),a("ul",[a("li",[t._v("((原始消息) + 秘钥)  *   函数函数 = 散列值(消息认证码)")])])]),t._v(" "),a("li",[t._v("将消息认证码发送给对方")])])]),t._v(" "),a("li",[t._v("接收者:\n"),a("ul",[a("li",[t._v("接收原始数据")]),t._v(" "),a("li",[t._v("接收消息认证码")]),t._v(" "),a("li",[t._v("校验:\n"),a("ul",[a("li",[t._v("( 接收的消息  +  秘钥 ) * 哈希函数   = 新的散列值")]),t._v(" "),a("li",[t._v("通过新的散列值和接收的散列值进行比较")])])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"_1-3-go中对消息认证码的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-go中对消息认证码的使用"}},[t._v("#")]),t._v(" 1.3 go中对消息认证码的使用")]),t._v(" "),a("blockquote",[a("p",[t._v("有一个包: crypto/hmac")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("New")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 返回值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" hash接口\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 函数函数的函数名\n\tsha1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("new")]),t._v("\n\tmd5"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("new")]),t._v("\n\tsha256"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("new")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 秘钥\n\n第二步"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 添加数据\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Hash "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误")]),t._v("\n    io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Writer\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 重设hash为无数据输入的状态")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Reset")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回Sum会返回的切片的长度")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回hash底层的块大小；Write方法可以接受任何大小的数据，")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但提供的数据是块大小的倍数时效率更高")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("BlockSize")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Writer "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n第三步"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 计算散列值\n")])])])]),t._v(" "),a("h3",{attrs:{id:"_1-4-消息认证码的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-消息认证码的问题"}},[t._v("#")]),t._v(" 1.4 消息认证码的问题")]),t._v(" "),a("ol",[a("li",[t._v("弊端\n"),a("ul",[a("li",[t._v("有秘钥分发困难的问题")])])]),t._v(" "),a("li",[t._v("无法解决的问题\n"),a("ul",[a("li",[t._v("不能进行第三方证明")]),t._v(" "),a("li",[t._v("不能防止否认")])])])]),t._v(" "),a("h2",{attrs:{id:"_04-数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_04-数字签名"}},[t._v("#")]),t._v(" 04 - 数字签名")]),t._v(" "),a("h3",{attrs:{id:"_2-1-签名的生成和验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-签名的生成和验证"}},[t._v("#")]),t._v(" 2.1 签名的生成和验证")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("签名\n"),a("ul",[a("li",[t._v("有原始数据对其进行哈希运算   ->   散列值")]),t._v(" "),a("li",[t._v("使用非对称加密的"),a("font",{attrs:{color:"red"}},[t._v("私钥")]),t._v("对散列值加密 -> 签名")],1),t._v(" "),a("li",[t._v("将原始数据和签名一并发送给对方")])])]),t._v(" "),a("li",[t._v("验证\n"),a("ul",[a("li",[t._v("接收数据\n"),a("ul",[a("li",[t._v("原始数据")]),t._v(" "),a("li",[t._v("数字签名")])])]),t._v(" "),a("li",[t._v("数字签名, 需要使用"),a("font",{attrs:{color:"red"}},[t._v("公钥")]),t._v("解密, 得到散列值")],1),t._v(" "),a("li",[t._v("对原始数据进行哈希运算得到新的散列值")])])])])]),t._v(" "),a("h3",{attrs:{id:"_2-2-非对称加密和数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-非对称加密和数字签名"}},[t._v("#")]),t._v(" 2.2 非对称加密和数字签名")]),t._v(" "),a("blockquote",[a("p",[t._v("总结:")]),t._v(" "),a("ol",[a("li",[t._v("数据通信\n"),a("ul",[a("li",[t._v("公钥加密, 私钥解密")])])]),t._v(" "),a("li",[t._v("数字签名:")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("- 私钥加密, 公钥解密\n")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-3-数字签名的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-数字签名的方法"}},[t._v("#")]),t._v(" 2.3 数字签名的方法")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day03/1539177860475.png",alt:"1539177860475"}})]),t._v(" "),a("h3",{attrs:{id:"_2-4-使用rsa进行数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-使用rsa进行数字签名"}},[t._v("#")]),t._v(" 2.4 使用RSA进行数字签名")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用rsa生成密钥对")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("生成密钥对")]),t._v(" "),a("li",[t._v("序列化")]),t._v(" "),a("li",[t._v("保存到磁盘文件")])])])]),t._v(" "),a("li",[a("p",[t._v("使用私钥进行数字签名")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("打开磁盘的私钥文件")])]),t._v(" "),a("li",[a("p",[t._v("将私钥文件中的内容读出")])]),t._v(" "),a("li",[a("p",[t._v("使用pem对数据解码, 得到了pem.Block结构体变量")])]),t._v(" "),a("li",[a("p",[t._v("x509将数据解析成私钥结构体 -> 得到了私钥")])]),t._v(" "),a("li",[a("p",[t._v("创建一个哈希对象 -> md5/sha1")])]),t._v(" "),a("li",[a("p",[t._v("给哈希对象添加数据")])]),t._v(" "),a("li",[a("p",[t._v("计算哈希值")])]),t._v(" "),a("li",[a("p",[t._v("使用rsa中的函数对散列值签名")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SignPKCS1v15")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rand io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Reader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" priv "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("PrivateKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hash crypto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hashed "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" rand"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Reader\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 非对称加密的私钥\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 使用的哈希算法\n\tcrypto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sha1\n\tcrypto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("md5\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 数据计算之后得到的散列值\n返回值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 得到的签名数据\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 错误信息\n")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("使用公钥进行签名认证")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("打开公钥文件, 将文件内容读出 - []byte")])]),t._v(" "),a("li",[a("p",[t._v("使用pem解码 -> 得到pem.Block结构体变量")])]),t._v(" "),a("li",[a("p",[t._v("使用x509对pem.Block中的Bytes变量中的数据进行解析 ->  得到一接口")])]),t._v(" "),a("li",[a("p",[t._v("进行类型断言 -> 得到了公钥结构体")])]),t._v(" "),a("li",[a("p",[t._v("对原始消息进行哈希运算(和签名使用的哈希算法一致) -> 散列值")]),t._v(" "),a("ol",[a("li",[t._v("创建哈希接口")]),t._v(" "),a("li",[t._v("添加数据")]),t._v(" "),a("li",[t._v("哈希运算")])])]),t._v(" "),a("li",[a("p",[t._v("签名认证 - rsa中的函数")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("VerifyPKCS1v15")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pub "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("PublicKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hash crypto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hashed "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sig "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 公钥\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 哈希算法 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 与签名使用的哈希算法一致\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 将原始数据进行哈希原始得到的散列值\n参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 签名的字符串\n返回值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 验证成功\n\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 失败\n")])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"_2-5-使用椭圆曲线进行数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-使用椭圆曲线进行数字签名"}},[t._v("#")]),t._v(" 2.5 使用椭圆曲线进行数字签名")]),t._v(" "),a("blockquote",[a("p",[t._v('椭圆曲线在go中对应的包: import "crypto/elliptic"')]),t._v(" "),a("p",[t._v('使用椭圆曲线在go中进行数字签名: import "crypto/ecdsa"')]),t._v(" "),a("p",[t._v("美国FIPS186-2标准, 推荐使用5个素域上的椭圆曲线, 这5个素数模分别是:")]),t._v(" "),a("p",[t._v("P~192~ = 2^192^ - 2^64^ - 1")]),t._v(" "),a("p",[t._v("P~224~ = 2^224^ - 2^96^ + 1")]),t._v(" "),a("p",[t._v("P~256~ = 2^256^ - 2^224^  + 2^192^ - 2^96^ -1")]),t._v(" "),a("p",[t._v("P~384~ = 2^384^ - 2^128^  - 2^96^ + 2^32^ -1")]),t._v(" "),a("p",[t._v("P~512~ = 2^512^ - 1")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("秘钥对称的生成, 并保存到磁盘")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("使用ecdsa生成密钥对")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("GenerateKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c elliptic"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Curve"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rand io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Reader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("priv "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("PrivateKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("将私钥写入磁盘")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用x509进行序列化")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MarshalECPrivateKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ecdsa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PrivateKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("将得到的切片字符串放入pem.Block结构体中")]),t._v(" "),a("p",[t._v("block := pem.Block{")]),t._v(" "),a("p",[t._v('Type : "描述....",')]),t._v(" "),a("p",[t._v("Bytes : MarshalECPrivateKey返回值中的切片字符串,")]),t._v(" "),a("p",[t._v("}")])]),t._v(" "),a("li",[a("p",[t._v("使用pem编码")]),t._v(" "),a("p",[t._v("pem.Encode();")])])])]),t._v(" "),a("li",[a("p",[t._v("将公钥写入磁盘")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("从私钥中得到公钥")])]),t._v(" "),a("li",[a("p",[t._v("使用x509进行序列化")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MarshalPKIXPublicKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pub "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("将得到的切片字符串放入pem.Block结构体中")]),t._v(" "),a("p",[t._v("block := pem.Block{")]),t._v(" "),a("p",[t._v('Type : "描述....",')]),t._v(" "),a("p",[t._v("Bytes : MarshalECPrivateKey返回值中的切片字符串,")]),t._v(" "),a("p",[t._v("}")])]),t._v(" "),a("li",[a("p",[t._v("使用pem编码")]),t._v(" "),a("p",[t._v("pem.Encode();")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("使用私钥进行数字签名")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("打开私钥文件, 将内容读出来 ->[]byte")])]),t._v(" "),a("li",[a("p",[t._v("使用pem进行数据解码 -> pem.Decode()")])]),t._v(" "),a("li",[a("p",[t._v("使用x509, 对私钥进行还原")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ParseECPrivateKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("der "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ecdsa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PrivateKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("对原始数据进行哈希运算 -> 散列值")])]),t._v(" "),a("li",[a("p",[t._v("进行数字签名")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sign")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rand io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Reader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" priv "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("PrivateKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hash "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("big"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 得到的r和s不能直接使用"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 因为这是指针\n\t应该将这两块内存中的数据进行序列化 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MarshalText")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("text "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("使用公钥验证数字签名")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("打开公钥文件, 将里边的内容读出 -> []byte")])]),t._v(" "),a("li",[a("p",[t._v("pem解码 -> pem.Decode()")])]),t._v(" "),a("li",[a("p",[t._v("使用x509对公钥还原")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ParsePKIXPublicKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("derBytes "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pub "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("将接口 -> 公钥")])]),t._v(" "),a("li",[a("p",[t._v("对原始数据进行哈希运算 -> 得到散列值")])]),t._v(" "),a("li",[a("p",[t._v("签名的认证 - > ecdsa")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Verify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pub "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("PublicKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hash "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("big"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 公钥\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 原始数据生成的散列值\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 参数"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 通过签名得到的连个点\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("UnmarshalText")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("text "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v("\n")])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"_2-6-数字签名无法解决的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-数字签名无法解决的问题"}},[t._v("#")]),t._v(" 2.6 数字签名无法解决的问题")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day03/1539178819165.png",alt:"1539178819165"}})]),t._v(" "),a("h2",{attrs:{id:"_05-证书"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_05-证书"}},[t._v("#")]),t._v(" 05 - 证书")]),t._v(" "),a("blockquote",[a("p",[t._v("公钥证书（Public-Key Certificate，PKC)其实和驾照很相似，里面记有姓名、组织、邮箱地址等"),a("font",{attrs:{color:"red"}},[t._v("个人信息")]),t._v("，以及属于"),a("font",{attrs:{color:"red"}},[t._v("此人的公钥, 并由认证机构（Certification Authority、Certifying Authority, CA）施加数字签名")]),t._v("。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate）。")],1)]),t._v(" "),a("h3",{attrs:{id:"_1-1-证书的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-证书的应用场景"}},[t._v("#")]),t._v(" 1.1 证书的应用场景")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day04/1539265302304.png",alt:"1539265302304"}})]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Bob生成密钥对")]),t._v(" "),a("ul",[a("li",[t._v("可以将bob看成百度, 提供是web服务器")]),t._v(" "),a("li",[t._v("生成一个密钥对\n"),a("ul",[a("li",[t._v("公钥  -> 分发")]),t._v(" "),a("li",[t._v("私钥 -> 百度留着")])])])])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Bob在认证机构Trent注册自己的公钥")])],1),t._v(" "),a("li",[a("ul",[a("li",[t._v("百度找了一大家都信赖的机构, 来证明这个公钥是百度的")]),t._v(" "),a("li",[t._v("认证机构会生成一个证书, 写明了公钥属于百度\n"),a("ul",[a("li",[t._v("认证机构也有一个非对称加密的密钥对")]),t._v(" "),a("li",[t._v("认证机构使用自己的私钥对百度的公钥进行签名, 生成了证书")]),t._v(" "),a("li",[t._v("认证机构将证书发送给百度")])])])])]),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书")])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书）")]),t._v(" "),a("ul",[a("li",[t._v("alice可以看做一个客户 -> 浏览器")]),t._v(" "),a("li",[t._v("客户端访问的百度 -> 得到了百度的证书\n"),a("ul",[a("li",[t._v("证书中有百度的公钥")])])]),t._v(" "),a("li",[t._v("客户端需要使用认证机构的公钥对证书进行验证\n"),a("ul",[a("li",[t._v("客户端怎么会有认证机构的公钥\n"),a("ul",[a("li",[t._v("window会预装, 或者用户自己安装")])])])])])])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性")]),t._v(" "),a("ul",[a("li",[t._v("使用认证机构的公钥解除百度证书中签名的数据\n"),a("ul",[a("li",[t._v("百度的公钥")]),t._v(" "),a("li",[t._v("百度的域名")]),t._v(" "),a("li",[t._v("百度证书的有效期")])])])])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Alice用Bob的公钥加密消息并发送给Bob")]),t._v(" "),a("ul",[a("li",[t._v("非对称加密")]),t._v(" "),a("li",[t._v("使用公钥加密 -> 对称加密秘钥分发")])])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red",size:"4"}},[t._v("Bob用自己的私钥解密密文得到Alice的消息")]),t._v(" "),a("ul",[a("li",[t._v("服务器使用私钥解密 -> 得到对称加密的秘钥")])])],1)])]),t._v(" "),a("h3",{attrs:{id:"_1-2-证书规范和格式-x509"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-证书规范和格式-x509"}},[t._v("#")]),t._v(" 1.2 证书规范和格式 -- x509")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("X.509")]),t._v("是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数据结构，并使用ASN.1语法进行编码。")]),t._v(" "),a("p",[t._v("X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。")]),t._v(" "),a("ul",[a("li",[t._v("证书文件的文件名后缀一般为 .crt 或 .cer")]),t._v(" "),a("li",[t._v("对应私钥文件的文件名后缀一般为 .key")]),t._v(" "),a("li",[t._v("证书请求文件的文件名后綴为 .csr")]),t._v(" "),a("li",[t._v("有时候也统一用pem作为文件名后缀。")])])]),t._v(" "),a("h3",{attrs:{id:"_1-3-ca证书"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-ca证书"}},[t._v("#")]),t._v(" 1.3  CA证书")]),t._v(" "),a("blockquote",[a("p",[t._v("CA证书顾名思义就是由CA（Certification Authority）机构发布的数字证书。要对CA证书完全理解及其作用，首先要理解SSL。SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议。SSL3.0版本以后又被称为TLS。SSL位于TCP与各应用层之间，是操作系统向外提供的API。SSL如何保证网络通信的安全和数据的完整性呢？就是采用了两种手段：身份认证和数据加密。首先身份认证就需要用到CA证书了。")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("证书的获取和身份的认证")]),t._v(" "),a("blockquote",[a("p",[t._v("客户端与服务端需要经过一个握手的过程才能完成身份认证，建立一个安全的连接。握手的过程如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("客户端访问服务器（比如："),a("a",{attrs:{href:"https://www.12306.cn/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.12306.cn"),a("OutboundLink")],1),t._v("）,发送ssl版本、客户端支持的加密算法等消息。")])]),t._v(" "),a("li",[a("p",[t._v("服务器向客户端发送ssl版本、加密算法、证书（证书出现了）等消息。")])]),t._v(" "),a("li",[a("p",[t._v("客户端收到消息后，判断证书是否可信, 若可信，则继续通信，发送消息：")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("客户端生成一个随机数，从证书中获取服务器端的公钥，对随机数加密；")])],1),t._v(" "),a("p",[t._v("随后信息都将使用双方协定的加密方法和密钥发送, 客户端握手结束。")])]),t._v(" "),a("li",[a("p",[t._v("服务器端对数据解密得到随机数, 使用协商好的加密算法和秘钥进行通信")])])])])]),t._v(" "),a("li",[a("p",[t._v("客户端如何验证CA证书是可信任的?")]),t._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[t._v("查看证书的方式:")]),t._v(" "),a("p",[t._v("Internet选项 -> 内容 -> 证书, 打开证书窗口查看已经安装的证书")]),t._v(" "),a("p",[t._v("只要电脑上安装了该证书, 就说明该证书是受信任的。使用https协议访问时，服务器发送证书向浏览器时，首先查找该证书是否已在信任列表中，然后对证书进行校验，校验成功，那么就证明证书是可信的。")]),t._v(" "),a("p",[t._v("下图中"),a("code",[t._v("受信任的根证书颁发机构")]),t._v("下的证书都是根证书。")]),t._v(" "),a("p",[t._v("证书验证的机制是只要根证书是受信任的，那么它的子证书都是可信的。比如说，我们使用https协议访问了需要百度证书的网站，即使我们不安装百度证书，那么网站也不会提示证书不安全，因为，生成百度证书的根证书"),a("code",[t._v("Globalsign Root CA - R1")]),t._v("证书，在受信任的证书列表中。如果一个证书的根证书是不可信的，那么这个证书肯定也是不可信任的。")]),t._v(" "),a("p",[t._v("由以上可知，根证书在证书验证中极其重要，而且，根证书是无条件信任的，只要我们将根证书安装上，就说明我们对根证书是信任的。比如我们安装12306的根证书，是出于我们对国家的信任，对网站的信任，我们才放心安装这个根证书。对于一些不安全的网站的证书，一定要慎重安装。")]),t._v(" "),a("p",[t._v("另外需要知道的是，【"),a("code",[t._v("受信任的根证书颁发机构")]),t._v("】中的证书是windows预先安装的一些证书，都是国际上很有权威的证书机构，他们证书的生成都有很严格的流程，因此他们的证书被认为是安全，就像我们相信银行是安全，所以把钱存入到银行。")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day04/1539272408707.png",alt:"1539272408707"}})]),t._v(" "),a("blockquote",[a("ol",{attrs:{start:"2"}},[a("li",[a("p",[t._v("证书的颁发机构 -> CA")]),t._v(" "),a("ul",[a("li",[t._v("发布根证书")]),t._v(" "),a("li",[t._v("中间证书")]),t._v(" "),a("li",[t._v("个人")])])]),t._v(" "),a("li",[a("p",[t._v("证书的信任链 -> 证书签发机构的信任链")]),t._v(" "),a("p",[t._v("A是一个可信赖证书签发机构, A信任B, B就有资格去签发证书")]),t._v(" "),a("p",[t._v("从等级上A比B高一级")])])])])]),t._v(" "),a("li",[a("p",[t._v("有哪些CA机构?")]),t._v(" "),a("blockquote",[a("p",[t._v("世界上较早的数字认证中心是美国的verisign"),a("code",[t._v("威瑞信")]),t._v("公司，在windows的证书窗口中可以看到好多verisign公司生成的证书, 美国的"),a("em",[t._v("DigiCert")])]),t._v(" "),a("p",[t._v("另外还有加拿大的ENTRUST公司，也是很著名的证书机构。")]),t._v(" "),a("p",[t._v("中国的安全认证体系分为金融CA和非金融CA。")]),t._v(" "),a("ul",[a("li",[t._v("在金融CA方面，根证书由中国人民银行管理，")]),t._v(" "),a("li",[t._v("非金融CA方面，由中国电信负责。\n"),a("ul",[a("li",[t._v("行业性CA\n"),a("ul",[a("li",[t._v("中国金融认证中心")]),t._v(" "),a("li",[t._v("中国电信认证中心")])])]),t._v(" "),a("li",[t._v("区域性CA, 区域性CA主要是以政府为背景，以企业机制运行\n"),a("ul",[a("li",[t._v("广东CA中心")]),t._v(" "),a("li",[t._v("上海CA中心")])])])])])]),t._v(" "),a("p",[t._v("沃通 -- www.wosign.com/products/ssl.htm")])])])]),t._v(" "),a("h3",{attrs:{id:"_1-4-公钥基础设施-pki"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-公钥基础设施-pki"}},[t._v("#")]),t._v(" 1.4 公钥基础设施 - PKI")]),t._v(" "),a("ol",[a("li",[t._v("PKI组成的要素\n"),a("ul",[a("li",[t._v("用户\n"),a("ul",[a("li",[t._v("申请证书的人 -> web服务器端\n"),a("ul",[a("li",[t._v("申请证书\n"),a("ul",[a("li",[t._v("生成密钥对 , 或者委托ca生成")]),t._v(" "),a("li",[t._v("将公钥发送给CA")]),t._v(" "),a("li",[t._v("ca使用自己的私钥对得到公钥签名")]),t._v(" "),a("li",[t._v("将证书发送给用户")])])]),t._v(" "),a("li",[t._v("发送证书\n"),a("ul",[a("li",[t._v("当客户端访问服务器的时候发送证书给客户端")])])]),t._v(" "),a("li",[t._v("注销证书\n"),a("ul",[a("li",[t._v("当发现私钥泄露之后")])])])])]),t._v(" "),a("li",[t._v("使用证书的人 -> 客户端\n"),a("ul",[a("li",[t._v("接收证书")]),t._v(" "),a("li",[t._v("验证对方的身份信息")])])])])]),t._v(" "),a("li",[t._v("CA认证机构\n"),a("ul",[a("li",[t._v("可以生产密钥对(可选)")]),t._v(" "),a("li",[t._v("对公钥签名")]),t._v(" "),a("li",[t._v("吊销证书")])])]),t._v(" "),a("li",[t._v("仓库\n"),a("ul",[a("li",[t._v("存储证书 -> 公钥")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_2-ssl-tls"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-ssl-tls"}},[t._v("#")]),t._v(" 2. SSL/TLS")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day04/1539271432019.png",alt:""}})]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("strong",[t._v("SSL")]),t._v("：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。\nSSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。")]),t._v(" "),a("li",[a("strong",[t._v("TLS")]),t._v("：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。\nTLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 "),a("a",{attrs:{href:"http://tools.ietf.org/html/rfc5246",target:"_blank",rel:"noopener noreferrer"}},[t._v("RFC"),a("OutboundLink")],1),t._v(" 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。")])]),t._v(" "),a("p",[t._v("SSL/TLS协议提供的服务主要有：")]),t._v(" "),a("ol",[a("li",[t._v("认证用户和服务器，确保数据发送到正确的客户机和服务器；")]),t._v(" "),a("li",[t._v("加密数据以防止数据中途被窃取；")]),t._v(" "),a("li",[t._v("维护数据的完整性，确保数据在传输过程中不被改变。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day04/tls-ssl.svg",alt:""}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("描述的是客户端和服务器刚建立连接之后做的事情")]),t._v(" "),a("p",[t._v("第一次")]),t._v(" "),a("ul",[a("li",[t._v("客户端连接服务器\n"),a("ul",[a("li",[t._v("客户端使用的ssl版本, 客户端支持的加密算法")])])]),t._v(" "),a("li",[t._v("服务器\n"),a("ul",[a("li",[t._v("先将自己支持ssl版本和客户端的支持的版本比较\n"),a("ul",[a("li",[t._v("支持的不一样, 连接断开")]),t._v(" "),a("li",[t._v("支持的一样, 继续")])])]),t._v(" "),a("li",[t._v("根据得到的客户端支持 的加密算法, 找一个服务器端也同样支持算法, 发送给客户端")]),t._v(" "),a("li",[t._v("需要发送服务器的证书给客户端")])])])]),t._v(" "),a("p",[t._v("第二次:")]),t._v(" "),a("p",[t._v("客户端:")]),t._v(" "),a("ul",[a("li",[t._v("接收服务器的证书")]),t._v(" "),a("li",[t._v("校验证书的信息\n"),a("ul",[a("li",[t._v("校验证书的签发机构")]),t._v(" "),a("li",[t._v("证书的有效期")]),t._v(" "),a("li",[t._v("证书中支持 的域名和访问的域名是否一致")])])]),t._v(" "),a("li",[t._v("校验有问题, 浏览器会给提示")])])])]),t._v(" "),a("h3",{attrs:{id:"_3-https-单向认证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-https-单向认证"}},[t._v("#")]),t._v(" 3. https -> 单向认证")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://static.zhequtao.com/study/04mimaxue/day04/https1.png",alt:""}})]),t._v(" "),a("ol",[a("li",[t._v("服务器要准备的\n"),a("ul",[a("li",[t._v("生成密钥对")]),t._v(" "),a("li",[t._v("将公钥发送给ca, 由ca签发证书")]),t._v(" "),a("li",[t._v("将ca签发的证书和非对称加密的私钥部署到当前的web服务器")])])]),t._v(" "),a("li",[t._v("通信流程\n"),a("ol",[a("li",[t._v("客户端连接服务器, 通过一个域名\n"),a("ul",[a("li",[t._v("域名和IP地址的关系\n"),a("ul",[a("li",[t._v("域名要绑定IP地址\n"),a("ul",[a("li",[t._v("一个域名只能绑定一个IP地址")])])]),t._v(" "),a("li",[t._v("IP地址需要被域名绑定\n"),a("ul",[a("li",[t._v("一个IP地址可以被多个域名绑定")])])])])]),t._v(" "),a("li",[t._v("客户端访问的域名会别解析成IP地址, 通过IP地址访问web服务器")])])]),t._v(" "),a("li",[t._v("服务器收到了客户端的请求\n"),a("ul",[a("li",[t._v("服务器将CA签发的证书发送给浏览器(客户端)")])])]),t._v(" "),a("li",[t._v("客户端拿到了服务器的公钥证书\n"),a("ul",[a("li",[t._v("读这个公钥 证书\n"),a("ul",[a("li",[t._v("验证域名")]),t._v(" "),a("li",[t._v("有效期")]),t._v(" "),a("li",[t._v("ca签发机构")]),t._v(" "),a("li",[t._v("服务器的公钥")])])])])]),t._v(" "),a("li",[t._v("客户会生成一个随机数 (作为对称加密的秘钥来使用的)\n"),a("ul",[a("li",[t._v("使用服务器的公钥就这个随机数进行加密")]),t._v(" "),a("li",[t._v("将这个加密之后 秘钥发送给服务器")])])]),t._v(" "),a("li",[t._v("服务器对收到的密文解密\n"),a("ul",[a("li",[t._v("使用服务器的是要解密, 得到对称加密的秘钥")])])]),t._v(" "),a("li",[t._v("数据的传输\n"),a("ul",[a("li",[t._v("使用对称加密的方式对数据进行加密")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_4-自签名证书"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-自签名证书"}},[t._v("#")]),t._v(" 4. 自签名证书")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用openssl生成自签名证书")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("创建一个目录如Mytest, 进入该目录, 在该目录下打开命令行窗口")])]),t._v(" "),a("li",[a("p",[t._v("启动openssl")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("openssl    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 执行该命令即可")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("使用openssl工具生成一个RSA私钥, 注意：生成私钥，需要提供一个至少4位的密码。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("genrsa -des3 -out server.key "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("\n\t- des3: 使用3des对私钥进行加密\n")])])])]),t._v(" "),a("li",[a("p",[t._v("生成CSR（证书签名请求）")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("req -new -key server.key -out server.csr\n")])])])]),t._v(" "),a("li",[a("p",[t._v("删除私钥中的密码, 第一步给私钥文件设置密码是必须要做的, 如果不想要可以删掉")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("rsa -in server.key -out server.key\n\t-out 参数后的文件名可以随意起\n")])])])]),t._v(" "),a("li",[a("p",[t._v("生成自签名证书")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("x509 -req -days "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("365")]),t._v(" -in server.csr -signkey server.key -out server.crt\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"证书总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#证书总结"}},[t._v("#")]),t._v(" 证书总结")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("消息认证码")]),t._v(" "),a("ul",[a("li",[t._v("是什么?\n"),a("ul",[a("li",[t._v("散列值")])])]),t._v(" "),a("li",[t._v("能干什么?\n"),a("ul",[a("li",[t._v("保证数据的完整性, 一致性")])])]),t._v(" "),a("li",[t._v("怎么生成?\n"),a("ul",[a("li",[t._v("准备的条件:  Hmac\n"),a("ul",[a("li",[t._v("原始数据")]),t._v(" "),a("li",[t._v("共享秘钥 -> 认证的另一方需要有同样的秘钥")]),t._v(" "),a("li",[t._v("哈希算法")])])])])]),t._v(" "),a("li",[t._v("弊端:\n"),a("ul",[a("li",[t._v("秘钥分发困难\n"),a("ul",[a("li",[t._v("使用非对称加密")])])]),t._v(" "),a("li",[t._v("不能第三方认证")]),t._v(" "),a("li",[t._v("不能防止否认")])])])])]),t._v(" "),a("li",[a("p",[t._v("数字签名")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("是什么?")]),t._v(" "),a("ul",[a("li",[t._v("签名\n"),a("ul",[a("li",[t._v("签名的人生成非对称加密的密钥对")]),t._v(" "),a("li",[t._v("签名的人将公钥进行分发")]),t._v(" "),a("li",[t._v("签名的人将原始数据进行哈希运算 -> 散列值")]),t._v(" "),a("li",[t._v("签名的人使用自己的私钥对散列值进行非对称加密 -> 最终得到的数据就是签名")])])]),t._v(" "),a("li",[t._v("校验:\n"),a("ul",[a("li",[t._v("接收签名人的公钥")]),t._v(" "),a("li",[t._v("接收签名人发送的数据和签名数据")]),t._v(" "),a("li",[t._v("对原始数据进行哈希运算 -> 散列值")]),t._v(" "),a("li",[t._v("使用公钥对签名数据解密")]),t._v(" "),a("li",[t._v("将解密出的数据和散列值进行比较\n"),a("ul",[a("li",[t._v("相等 == 成功")]),t._v(" "),a("li",[t._v("不..  == 失败")])])])])])])]),t._v(" "),a("li",[a("p",[t._v("干什么?")]),t._v(" "),a("ul",[a("li",[t._v("保证数据的一致性")]),t._v(" "),a("li",[t._v("进行第三方认证")]),t._v(" "),a("li",[t._v("可以防止否认")])])]),t._v(" "),a("li",[a("p",[t._v("能解决消息认证的弊端吗?")]),t._v(" "),a("ul",[a("li",[t._v("可以")])])]),t._v(" "),a("li",[a("p",[t._v("怎么进行签名")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("RSA")])]),t._v(" "),a("li",[a("p",[t._v("椭圆曲线签名 -> ecdsa")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("生成密钥对, 保存到文件中")]),t._v(" "),a("li",[t._v("对公钥进行分发")]),t._v(" "),a("li",[t._v("签名的人\n"),a("ul",[a("li",[t._v("将私钥从磁盘读出")]),t._v(" "),a("li",[t._v("pem解码")]),t._v(" "),a("li",[t._v("x509解码 -> 私钥结构体")]),t._v(" "),a("li",[t._v("对原始数据进行哈希运算 -> 散列值")]),t._v(" "),a("li",[t._v("签名")])])]),t._v(" "),a("li",[t._v("验证签名的人\n"),a("ul",[a("li",[t._v("将公钥从磁盘读出")]),t._v(" "),a("li",[t._v("pem解码")]),t._v(" "),a("li",[t._v("x509解码 -> 公钥")]),t._v(" "),a("li",[t._v("生成原始数据的散列值")]),t._v(" "),a("li",[t._v("签名认证")])])])])])])]),t._v(" "),a("p",[t._v("数字签名的缺陷?")]),t._v(" "),a("ul",[a("li",[t._v("验证签名的一方没有办法判断得到的公钥到底属于谁")])])])])])])])])])}),[],!1,null,null,null);s.default=_.exports}}]);